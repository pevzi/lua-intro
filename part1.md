Вот, наконец, и моя попытка написать введение в язык Lua. Я всё-таки постараюсь описать всё в меру подробно, упоминая разные полезные (с моей точки зрения) детали, на которые можно не сразу обратить внимание. Конкретно про LÖVE здесь ничего не будет, только чистый Lua. Но экспериментировать с языком, конечно, можно и запуская скрипты через LÖVE.

Ну, поехали.

В статье будут использоваться так называемые комментарии - последовательности символов в коде, не воспринимающиеся лексическим анализатором и использующиеся (внезапно) для комментирования кода.

В языке Lua два дефиса начинают однострочный комментарий (заканчивающийся переносом строки):

print("hello world") -- любое значение можно выводить в консоль при помощи функции print

Комментарии также удобно использовать для того, чтобы временно "отключить" кусок кода:

print(10)
-- print(20)

--[[ Двойные квадратные скобки
превращают комментарий в многострочный.
--]]

Кстати, многострочные комментарии имеют интересную особенность. Если мы использовали их для закомментирования кода, то временно "включить" этот код обратно можно просто добавив один дефис в первой строке:

-- до (многострочный комментарий):

--[[
print(10)
print(20)
--]]

-- после (обе строки с дефисами воспринимаются как однострочные комментарии):

---[[
print(10)
print(20)
--]]

Оператор = используется для присваивания значений переменным:

ultimateAnswer = 42 -- устанавливаем значение 42 переменной ultimateAnswer
favoriteFood = "spaghetti" -- ну вы поняли

Lua является языком с динамической типизацией. Это означает, что сами по себе переменные не имеют закреплённого за ним типа: тип имеют только значения, на которые эти переменные указывают. То есть, в определённый момент времени за переменной может скрываться что угодно, вне зависимости от того, что там было раньше. Следовательно, можно сделать, например, так:

phi = 1.618
phi = "ayy lmao" -- это не вызовет никакой ошибки

Одной из особенностей языка является то, что обращение к переменным, значение которых не было задано, так же не является ошибкой - значение всех переменных по умолчанию равно nil. nil - это особое значение, символизирующее отсутствие какого-либо другого значения. Его можно присвоить переменной вручную:

phi = nil -- теперь переменная phi снова не определена

Конечно, справа от знака присваивания можно использовать и выражения. Выражением является конструкция, принимающая в результате выполнения программы некоторое значение.

a = 5
b = a + 10 -- a + 10 это выражение, которое принимает значение 15

Ещё одна особенность: слева от оператора присваивания может находиться несколько переменных, так же, как и справа от него может быть несколько выражений:

x, y, z = 5, 6, 7

Если значений окажется меньше, чем переменных, то переменные, которым не хватило значений, примут значение nil. Если же значений наоборот больше, то лишние значения просто отбрасываются.

a, b, c = 1, 2 -- c = nil
d, e = 7, 8, 9 -- девятка игнорируется

Также следует отметить, что язык не предусматривает никакого ручного управления выделением и освобождением памяти. Значения, на которые не ссылается ни одна переменная, будут в конце концов автоматически удалены сборщиком мусора.

В Lua существует всего 8 типов данных:

- nil
- number
- string
- boolean
- function
- table
- userdata
- thread

Тип number представляет вещественные числа с двойной точностью (в других языках этот тип ещё называется double). То есть, единственный числовой тип в Lua - это числа с плавающей точкой, целых чисел в нём нет (примечание: целые числа появились в версии 5.3, но она здесь не рассматривается, так как не используется в LÖVE). В целом, это не проблема, ибо тип number позволяет хранить целочисленные значения размером в 15 десятичных знаков без потери точности, так что его можно спокойно использовать там, где нужны счётчики, индексы и т. д.

Этот тип поддерживает привычные арифметические операции:

x = x + vx * dt -- сложение и умножение
u = v / 2 - 1 -- вычитание и деление
a = -b -- унарный минус
offset = x % width -- остаток от деления (также известное как "деление по модулю")
foo = 2 ^ 10 -- возведение в степень

Однако, в языке нет не только операторов инкремента и декремента (++ и --), но даже составных операторов присваивания (таких как +=, *= и других). Так что, готовьтесь к строкам вида i = i + 1.

Тип string позволяет хранить строковые значения. Можно использовать как одинарные кавычки, так и двойные (однако, желательно придерживаться всё-таки одного стиля в пределах одной программы):

wtf = 'Lorem ipsum'
dogSpeech = "Hello, I'm a dog. Woof." -- если строка сама содержит апостроф ', то нужно использовать двойные кавычки

Как было сказано ранее, память под строки выделять вручную не нужно. Строки в Lua являются неизменяемыми, и одинаковые строки хранятся в памяти только в одном экземпляре. Из этого следует, что выполнение каких-либо операций над строками приводит к созданию новой строки.

В пределах строки можно использовать escape-последовательности, такие как \n (перенос строки), \t (табуляция), \\ (обратный слэш) и другие.

geese = "Жили у бабуси\nДва весёлых гуся"

Строки также можно записывать в двойных квадратных скобках. В этом случае язык воспринимает строки буквально, т.е. не обрабатывает escape-последовательности и считает переносы частью строки (но не учитывает первый символ, если он является переносом).

triforce = [[
 x
x x
]]

При попытке выполнения арифметической операции над строкой Lua пробует автоматически сконвертировать её в число:

print("10" + 1) -- 11
print("2" + "3") -- 5
print(4 * "3") -- 12
print("what" / 5) -- ошибка

Да, здесь не может неожиданно получиться "23" при попытке сложить "2" и "3" (смотрит такой в сторону кое-какого языка), так как для конкатенации (соединения) строк существует отдельный оператор:

print("abc" .. "def") -- "abcdef"
print(2 .. 3) -- "23"

Этот оператор, как и следует ожидать, при попытке применения к числу автоматически преобразует его в строку.

Тип boolean имеет два возможных значения - true и false, символизирующие, соответственно, истину и ложь. Эти значения получаются, например, при выполнении операций сравнения: == (равно), ~= (не равно), < (меньше), <= (меньше либо равно), > (больше), >= (больше либо равно).

print(7 * 8 == 56) -- true
print(2 ^ 10 < 1000) -- false
print("a" .. "b" == "ab") -- true

Как было сказано выше, одинаковые строки хранятся в памяти в одном экземпляре. Из этого следует, что строки являются посимвольно одинаковыми только в случае, если это и есть одна и та же строка. Таким образом, сравнение строк происходит очень быстро вне зависимости от их длины.

Строки также можно сравнивать и отношениями порядка (это которые < и прочие). Тогда они сравниваются по алфавиту:

print("abc" < "acc") -- true
print("12" > "5") -- false

Стоит отметить, что при использовании операторов сравнения язык никогда не пытается автоматически привести типы, то есть значения разных типов всегда не равны, а отношения порядка при попытке применения к разным типам вызывают ошибку:

print("5" == 5) -- false
print(10 == true) -- false
print("2" < 3) -- ошибка

Операторы and, or и not позволяют выполнять логические операции И, ИЛИ и НЕ:

print(true and false) -- false
print(true or false) -- true
print(not true) -- false

При применении к значениям типа boolean они работают ожидаемым от таких операторов образом:

- and даёт true только если оба аргумента равны true
- or даёт true если хотя бы один из аргументов равен true
- not даёт обратное значение

Однако, эти операторы могут работать не только над boolean, но и над любыми другими значениями. При этом ложными значениями считаются только false и nil, любое другое значение - истинно (в том числе 0 и пустая строка ""). Логика же этих операторов заключается в следующем:

- and даёт первый аргумент, если он ложный, иначе - второй
- or даёт первый аргумент, если он истинный, иначе - второй
- not всегда даёт значение типа boolean

Такое поведение операторов позволяет применять парочку интересных трюков с их использованием. Например, когда нужно установить переменной значение по умолчанию, если она равна nil, в большинстве случаев можно сделать так:

x = x or 5 -- если x не задан, установим его значение равным 5

Но стоит учесть, что такой приём неприменим, если false считается заданным корректным значением.

Другой трюк позволяет обойти проблему отсутствия в языке тернарного оператора, аналогичного a ? b : c из Си-образных языков:

result = a and b or c -- если a истинно, то result = b, иначе result = c

Например, выбор максимального значения из двух выглядит так:

max = (x > y) and x or y

Здесь так же, как и в предыдущем случае, есть загвоздка: b не должно быть ложным (nil или false). Если b окажется ложным, то выражение в любом случае вернёт c, так как выражение (a and b) будет ложно.

Приоритет операторов чётко определён (от высшего к низшему):

^
not  - (унарный)
*   /
+   -
..
<   >   <=  >=  ~=  ==
and
or

То есть, в сложном выражении используемые операторы будут выполняться именно в этом порядке. Если забыли, кто за кем следует, тупо используйте круглые скобки:

wtf = (a > b) and (a < c) -- чтоб наверняка

Вот, в принципе, и всё для начала. Другие типы будут рассмотрены позже.

В следующей серии: блоки, ветвление, циклы и функции.
