Вот, наконец, и моя попытка написать введение в язык Lua. Я всё-таки постараюсь описать всё в меру подробно, упоминая разные полезные (с моей точки зрения) детали, на которые можно не сразу обратить внимание. Конкретно про LÖVE здесь ничего не будет, только чистый Lua. Но экспериментировать с языком, конечно, можно и запуская скрипты через LÖVE.

Ну, поехали.

#### Комментарии

В статье будут использоваться так называемые комментарии - последовательности символов в коде, не воспринимающиеся лексическим анализатором и использующиеся (внезапно) для комментирования кода.

В языке Lua два дефиса начинают однострочный комментарий (заканчивающийся переносом строки):

```lua
print("hello world") -- любое значение можно выводить в консоль при помощи функции print
```

Комментарии также удобно использовать для того, чтобы временно "отключить" кусок кода:

```lua
print(10)
-- print(20)
```

```lua
--[[ Двойные квадратные скобки
превращают комментарий в многострочный.
--]]
```

Кстати, многострочные комментарии имеют интересную особенность. Если мы использовали их для закомментирования кода, то временно "включить" этот код обратно можно просто добавив один дефис в первой строке.

До (многострочный комментарий):

```lua
--[[
print(10)
print(20)
--]]
```

После (обе строки с дефисами воспринимаются как однострочные комментарии):

```lua
---[[
print(10)
print(20)
--]]
```

#### Присваивание

Оператор = используется для присваивания значений переменным:

```lua
ultimateAnswer = 42 -- устанавливаем значение 42 переменной ultimateAnswer
favoriteFood = "spaghetti" -- ну вы поняли
```

Имя переменной может состоять из букв, цифр и знака подчёркивания, но не может начинаться с цифры. Также оно не должно совпадать с зарезервированными языком словами (такими как return, local, function и другими).

Lua является языком с динамической типизацией. Это означает, что сами по себе переменные не имеют закреплённого за ним типа: тип имеют только значения, на которые эти переменные указывают. То есть, в определённый момент времени за переменной может скрываться что угодно, вне зависимости от того, что там было раньше. Следовательно, можно сделать, например, так:

```lua
phi = 1.618
phi = "ayy lmao" -- это не вызовет никакой ошибки
```

Одной из особенностей языка является то, что обращение к переменным, значение которых не было задано, так же не является ошибкой - значение всех переменных по умолчанию равно nil. nil - это особое значение, символизирующее отсутствие какого-либо другого значения. Его можно присвоить переменной вручную:

```lua
phi = nil -- теперь переменная phi снова не определена
```

Конечно, справа от знака присваивания можно использовать и выражения. Выражением является конструкция, принимающая в результате выполнения программы некоторое значение. Выражением в том числе является просто отдельный числовой, строковый или иной литерал (т.е. явно указанное в тексте программы значение):

```lua
a = 5 -- просто 5 это тоже выражение
b = a + 10 -- a + 10 это выражение, которое принимает значение 15
```

Слева от оператора присваивания может находиться несколько переменных, а справа - несколько выражений. Тогда первая переменная принимает первое значение, вторая - второе, и т.д.

```lua
x, y, z = 5, 6, 7
```

При этом сначала вычисляются значения всех указанных выражений, а потом уже происходит присваивание.

Это также позволяет обменять значения двух переменных между собой, в одну строку и без использования промежуточных переменных:

```lua
a, b = b, a
```

Если значений окажется меньше, чем переменных, то переменные, которым не хватило значений, примут значение nil. Если же значений наоборот больше, то лишние значения просто отбрасываются.

```lua
a, b, c = 1, 2 -- c = nil
d, e = 7, 8, 9 -- девятка игнорируется
```

#### Типы данных

В Lua существует всего 8 типов данных:

- nil
- number
- string
- boolean
- function
- table
- userdata
- thread

##### number

Тип number представляет вещественные числа с двойной точностью (в других языках этот тип ещё называется double). То есть, единственный числовой тип в Lua - это числа с плавающей точкой, целых чисел в нём нет (примечание: целые числа появились в версии 5.3, но она здесь не рассматривается, так как не используется в LÖVE). В целом, это не проблема, ибо тип number позволяет хранить целочисленные значения размером в 15 десятичных знаков без потери точности, так что его можно спокойно использовать там, где нужны счётчики, индексы и т. д.

Этот тип поддерживает привычные арифметические операции:

```lua
x = x + vx * dt -- сложение и умножение
u = v / 2 - 1 -- вычитание и деление
a = -b -- унарный минус
offset = x % width -- остаток от деления (также известное как "деление по модулю")
foo = 2 ^ 10 -- возведение в степень
```

Однако, в языке нет не только операторов инкремента и декремента (++ и --), но даже составных операторов присваивания (таких как +=, \*= и других). Так что, готовьтесь к строкам вида i = i + 1.

##### string

Тип string позволяет хранить строковые значения (текст). Можно использовать как одинарные кавычки, так и двойные (однако, желательно придерживаться всё-таки одного стиля в пределах одной программы):

```lua
wtf = 'Lorem ipsum'
dogSpeech = "Hello, I'm a dog. Woof." -- если строка сама содержит апостроф ', то нужно использовать двойные кавычки
```

Выделять память под строки и впоследствии очищать её вручную не нужно, всё это делается автоматически. Строки в Lua являются неизменяемыми, и одинаковые строки хранятся в памяти только в одном экземпляре. Из этого следует, что выполнение каких-либо операций над строками приводит к созданию новой строки. Строки, на которые не ссылается ни одна переменная, считаются недоступными и автоматически удаляются из памяти сборщиком мусора.

В пределах строки можно использовать escape-последовательности, такие как \\n (перенос строки), \\t (табуляция), \\\\ (обратный слэш) и другие.

```lua
geese = "Жили у бабуси\nДва весёлых гуся"
```

Строки также можно записывать в двойных квадратных скобках. В этом случае язык воспринимает строки буквально, т.е. не обрабатывает escape-последовательности и считает переносы частью строки (но не учитывает первый символ, если он является переносом).

```lua
triforce = [[
 x
x x
]]
```

Если внутри строки требуется использовать двойные квадратные скобки, то можно сделать так:

```lua
brackets = [=[
text [[ text ]] text
]=]
```

Количество знаков равенства может быть любым, но должно совпадать у открывающей и закрывающей "скобки".

При попытке выполнения арифметической операции над строкой Lua пробует автоматически сконвертировать её в число:

```lua
print("10" + 1) --> 11
print("2" + "3") --> 5
print(4 * "3") --> 12
print("what" / 5) -- ошибка
```

Да, здесь не может неожиданно получиться "23" при попытке сложить "2" и "3" (смотрит такой в сторону кое-какого языка), так как для конкатенации (соединения) строк существует отдельный оператор:

```lua
print("abc" .. "def") --> "abcdef"
print(2 .. 3) --> "23"
```

Этот оператор, как и следует ожидать, при попытке применения к числу автоматически преобразует его в строку.

Оператор # используется для определения длины строки.

```lua
greeting = "hello"
print(#greeting) --> 5
```

Однако, стоит заметить, что он возвращает не количество символов в строке, а количество байт, из которых она состоит, и это количество может быть другим в случае использования Unicode.

Дело в том, что Lua ничего не знает о кодировках. Строка может быть любой последовательностью байт, и разработчик может работать с ней так, как ему нужно. В дальнейшем будет рассмотрена библиотека, реализующая некоторые средства для обработки кодировки UTF-8.

##### boolean

Тип boolean имеет два возможных значения - true и false, символизирующие, соответственно, истину и ложь. Эти значения получаются, например, при выполнении операций сравнения: == (равно), ~= (не равно), < (меньше), <= (меньше либо равно), > (больше), >= (больше либо равно).

```lua
print(7 * 8 == 56) --> true
print(2 ^ 10 < 1000) --> false
print("a" .. "b" == "ab") --> true
```

Как было сказано выше, одинаковые строки хранятся в памяти в одном экземпляре. Из этого следует, что строки являются посимвольно одинаковыми только в случае, если это и есть одна и та же строка. Таким образом, сравнение строк происходит очень быстро вне зависимости от их длины.

Строки также можно сравнивать и отношениями порядка (это которые < и прочие). Тогда они сравниваются по алфавиту:

```lua
print("abc" < "acc") --> true
print("12" > "5") --> false
```

Стоит отметить, что при использовании операторов сравнения язык никогда не пытается автоматически привести типы, то есть значения разных типов всегда не равны, а отношения порядка при попытке применения к разным типам вызывают ошибку:

```lua
print("5" == 5) --> false
print(10 == true) --> false
print("2" < 3) -- ошибка
```

Операторы and, or и not позволяют выполнять логические операции И, ИЛИ и НЕ:

```lua
print(true and false) -- false
print(true or false) -- true
print(not true) -- false
```

При применении к значениям типа boolean они работают ожидаемым от таких операторов образом:

- and даёт true только если оба его операнда равны true;
- or даёт true если хотя бы один из его операндов равен true;
- not даёт обратное значение операнда.

Как и во многих других языках, при использовании and или or значение второго операнда даже не вычисляется, если результат выполнения операции and/or понятен уже из значения первого выражения. Этот факт становится важным, когда в выражениях используются вызовы функций (которые будут рассмотрены в пятой части). Например, в следующих примерах вызова функций не происходит, так как вычислять второе значение не требуется:

```lua
print(false and isSquare(x)) --> false
print(true or isEven(y)) --> true
```

Операторы and, or и not могут работать не только над boolean, но и над любыми другими значениями. При этом ложными значениями считаются только false и nil, любое другое значение - истинно (в том числе 0 и пустая строка ""). Результатом выполнения and и or будет являться значение того операнда, который определил итоговое значение. То есть:

- and даёт значение первого операнда, если он ложный, иначе - второго;
- or даёт значение первого операнда, если он истинный, иначе - второго.

```lua
print(5 and 8) --> 8
print(5 or 8) --> 5
print(nil and 5) --> nil
print(false or 5) --> 5
```

not же всегда даёт значение типа boolean, обратное истинности операнда.

```lua
print(not 0) --> false
print(not nil) --> true
```

Такое поведение операторов позволяет применять парочку интересных трюков с их использованием. Например, когда нужно установить переменной значение по умолчанию, если она равна nil, в большинстве случаев можно сделать так:

```lua
x = x or 5 -- если x не задан, установим его значение равным 5
```

Но стоит учесть, что такой приём неприменим, если false считается заданным корректным значением.

Другой трюк позволяет обойти проблему отсутствия в языке тернарного оператора, аналогичного a ? b : c из Си-образных языков:

```lua
result = a and b or c -- если a истинно, то result = b, иначе result = c
```

Например, выбор максимального значения из двух выглядит так:

```lua
max = (x > y) and x or y
```

Здесь так же, как и в предыдущем случае, есть загвоздка: b не должно быть ложным (nil или false). Если b окажется ложным, то выражение в любом случае вернёт c, так как выражение (a and b) будет ложно.

Приоритет операторов чётко определён (от высшего к низшему):

```lua
^
not  - (унарный)
*   /
+   -
..
<   >   <=  >=  ~=  ==
and
or
```

То есть, в сложном выражении используемые операторы будут выполняться именно в этом порядке. Если забыли, кто за кем следует, тупо используйте круглые скобки:

```lua
wtf = (a > b) and (a < c) -- чтоб наверняка
```

##### userdata

Как известно, Lua используется как язык, встраиваемый в другие приложения. Значение типа userdata - это просто кусок данных, переданный Lua-коду из основной программы. Сам язык не определяет никаких операций над этим типом, кроме присваивания и сравнения; любые другие операции реализуются разработчиком в приложении и предоставляются Lua-коду в виде функций. Тип userdata обычно используется для представления пользовательских типов данных. Например, используемые в фреймворке LÖVE объекты вроде Image, Source или SpriteBatch являются значениями типа userdata. Подробно останавливаться на этом типе не будем, так как он связан с API для взаимодействия с приложением, а это уже выходит за рамки введения.

Вот и всё для начала. Типы table, function и thread будут рассмотрены позже.
