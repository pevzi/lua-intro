#### Комментарии

В статье будут использоваться так называемые комментарии - последовательности символов в коде, не воспринимающиеся языком и использующиеся (внезапно) для комментирования кода.

В языке Lua два дефиса начинают однострочный комментарий (заканчивающийся переносом строки):

```lua
print("hello world") -- значение любого выражения можно вывести в консоль при помощи функции print
```

Комментарии также удобно использовать для того, чтобы временно "отключить" кусок кода:

```lua
print(10)
-- print(20)
```

```lua
--[[ Двойные квадратные скобки
превращают комментарий в многострочный.
--]]
```

Кстати, многострочные комментарии имеют интересную особенность. Если мы использовали их для закомментирования кода, то временно "включить" этот код обратно можно просто добавив один дефис в первой строке.

До (многострочный комментарий):

```lua
--[[
print(10)
print(20)
--]]
```

После (обе строки с дефисами воспринимаются как однострочные комментарии):

```lua
---[[
print(10)
print(20)
--]]
```

#### Присваивание

Оператор = используется для присваивания значений переменным:

```lua
ultimateAnswer = 42 -- устанавливаем значение 42 переменной ultimateAnswer
favoriteFood = "spaghetti" -- ну вы поняли
```

Переменную можно воспринимать как нечто имеющее имя и хранящее некоторое значение. Операция присваивания копирует в указанную переменную значение выражения, располагающегося справа от знака равенства.

Имя переменной может состоять из букв, цифр и знака подчёркивания, но не может начинаться с цифры. Также оно не должно совпадать с зарезервированными языком словами (такими как return, local, function и другими).

Lua является языком с динамической типизацией. Это означает, что сами по себе переменные не имеют закреплённого за ним типа: тип имеют только значения. То есть, в определённый момент времени в переменной может лежать что угодно, вне зависимости от того, что там было раньше. Следовательно, можно сделать, например, так:

```lua
phi = 1.618
phi = "ayy lmao" -- это не вызовет никакой ошибки
```

Одной из особенностей языка является то, что обращение к переменным, значение которых не было задано, так же не является ошибкой - значение всех переменных по умолчанию равно nil. nil - это особое значение, символизирующее отсутствие какого-либо другого значения. Его можно присвоить переменной вручную:

```lua
phi = nil -- теперь переменная phi снова не определена
```

Как было сказано выше, справа от оператора присваивания ожидается выражение. Выражением является конструкция, принимающая в ходе выполнения программы некоторое значение. Это может быть как отдельно стоящий строковый, числовой или иной литерал (т.е. явно указанное в тексте программы значение), так и нечто более сложное, включающее в себя арифметические операции, переменные и другое:

TODO: может не "конструкция, принимающая значение", а как-нибудь поточнее? когда обрабатывается выражение, вычисляется его значение (в разные моменты работы программы значение может быть разным)

```lua
a = 5 -- просто 5 это тоже выражение
b = a + 10 -- a + 10 это выражение, которое принимает значение 15
c = math.sqrt(81) / (b - 9) -- выражение, включающее в себя вызов функции для извлечения квадратного корня
```

Слева от оператора присваивания может находиться несколько переменных, а справа - несколько выражений. Тогда первая переменная принимает первое значение, вторая - второе, и т.д.

```lua
x, y, z = 5, 6, 7
```

При этом сначала вычисляются значения всех указанных выражений, а потом уже происходит присваивание:

```lua
a = 16
b = 9
a, b = a + b, a - b  -- a --> 25, b --> 7
```

Это также позволяет обменять значения двух переменных между собой, в одну строку и без использования промежуточных переменных:

```lua
a, b = b, a
```

Если значений окажется меньше, чем переменных, то переменные, которым не хватило значений, примут значение nil. Если же значений наоборот больше, то лишние значения просто отбрасываются.

```lua
a, b, c = 1, 2 -- c = nil
d, e = 7, 8, 9 -- девятка игнорируется
```

#### Типы данных

В Lua существует всего 8 типов данных:

- **nil**: единственное значение данного типа - nil, назначение которого - отличаться от любого другого значения;
- **number**: вещественное число;
- **string**: строка (текст или любая другая последовательность байт);
- **boolean**: два возможных значения - true (истина) или false (ложь);
- **function**: функция (некий код, который можно выполнить);
- **table**: таблица (составной тип данных, позволяющий группировать значения в единую сущность);
- **userdata**: произвольные данные, переданные основной программой в Lua-код;
- **thread**: сопрограмма.

Типы table, function и thread будут рассмотрены в следующих статьях.

##### number

Тип number представляет вещественные числа с двойной точностью (в других языках этот тип ещё называется double). То есть, единственный числовой тип в Lua - это числа с плавающей точкой, целых чисел в нём нет (примечание: целые числа появились в версии 5.3, но она здесь не рассматривается, так как не используется в LÖVE). В целом, это не проблема, ибо тип number позволяет хранить целочисленные значения размером около 15 десятичных знаков без потери точности, так что его можно спокойно использовать там, где нужны счётчики, индексы и т. д.

Этот тип поддерживает привычные арифметические операции:

```lua
x = x + vx * dt -- сложение и умножение
u = v / 2 - 1 -- вычитание и деление
a = -b -- унарный минус
offset = x % width -- остаток от деления (также известное как "деление по модулю")
foo = 2 ^ 10 -- возведение в степень
```

Однако, в языке нет не только операторов инкремента и декремента (++ и --), но даже составных операторов присваивания (таких как +=, \*= и других). Так что, готовьтесь к строкам вида i = i + 1.

##### string

Тип string позволяет хранить строковые значения (текст). Можно использовать как одинарные кавычки, так и двойные:

```lua
wtf = 'Lorem ipsum'
dogSpeech = "Hello, I'm a dog. Woof." -- строки в двойных кавычках могут содержать одинарные кавычки (и наоборот)
```

В пределах строки можно использовать управляющие последовательности, такие как \\n (перенос строки), \\t (табуляция), \\\\ (обратный слэш), \\', \\" (одинарная и двойная кавычки) и другие.

```lua
geese = "Жили у бабуси\nДва весёлых гуся"
```

Строки также можно записывать в двойных квадратных скобках. В этом случае язык воспринимает строки буквально, т.е. не обрабатывает управляющие последовательности и считает переносы частью строки (но для удобства написания не учитывает первый символ, если он является переносом).

```lua
triforce = [[
 x
x x
]]
```

Если внутри строки требуется использовать двойные квадратные скобки, то можно сделать так:

```lua
brackets = [=[
text [[ text ]] text
]=]
```

Количество знаков равенства может быть любым, но должно совпадать у открывающей и закрывающей "скобки".

При попытке выполнения арифметической операции над строкой Lua пробует автоматически сконвертировать её в число:

```lua
print("10" + 1) --> 11
print("2" + "3") --> 5
print(4 * "3") --> 12
print("what" / 5) -- ошибка
```

Да, здесь не может неожиданно получиться "23" при попытке сложить "2" и "3" (смотрит такой в сторону кое-какого языка), так как для конкатенации (соединения) строк существует отдельный оператор:

```lua
print("abc" .. "def") --> abcdef
print(2 .. 3) --> 23
```

Этот оператор, как и следует ожидать, при попытке применения к числу автоматически преобразует его в строку.

Оператор # используется для определения длины строки.

```lua
greeting = "hello"
print(#greeting) --> 5
```

Однако, стоит заметить, что он возвращает не количество символов в строке, а количество байт, из которых она состоит, и это количество может быть другим в случае использования Unicode.

Дело в том, что Lua ничего не знает о кодировках. Строка может быть любой последовательностью байт, и разработчик может работать с ней так, как ему нужно. В дальнейшем будет рассмотрена библиотека, реализующая некоторые средства для обработки кодировки UTF-8.

#### Другие операторы

Lua поддерживает ряд привычных операторов сравнения: == (равно), ~= (не равно), < (меньше), <= (меньше либо равно), > (больше), >= (больше либо равно). При выполнении этих операций получаются значения типа boolean, т.е. либо true (истина), либо false (ложь):

```lua
print(7 * 8 == 56) --> true
print(2 ^ 10 < 1000) --> false
print("a" .. "b" == "ab") --> true
```

Сравнение строк с помощью операторов == и ~= показывает, совпадают ли строки посимвольно. Строки также можно сравнивать и отношениями порядка (это которые < и прочие). Тогда они сравниваются по алфавиту:

```lua
print("abc" < "acc") --> true
print("12" > "5") --> false
```

Стоит отметить, что при использовании операторов сравнения язык никогда не пытается автоматически привести типы, то есть значения разных типов всегда не равны, а отношения порядка при попытке применения к разным типам вызывают ошибку:

```lua
print("5" == 5) --> false
print(10 == true) --> false
print("2" < 3) -- ошибка
```

Операторы and, or и not позволяют выполнять логические операции И, ИЛИ и НЕ:

TODO: уж слишком про них многословно

```lua
print(true and false) -- false
print(true or false) -- true
print(not true) -- false
```

При применении к значениям типа boolean они работают ожидаемым от таких операторов образом:

- and даёт true только если оба его операнда равны true;
- or даёт true если хотя бы один из его операндов равен true;
- not даёт обратное значение операнда.

Как и во многих других языках, при использовании and или or значение второго операнда даже не вычисляется, если результат выполнения операции and/or понятен уже из значения первого выражения. Например, в следующих примерах вызова функций не происходит, так как вычислять второе значение не требуется:

```lua
print(false and isSquare(x)) --> false
print(true or isEven(y)) --> true
```

Операторы and, or и not могут работать не только над boolean, но и над любыми другими значениями. При этом ложными значениями считаются только false и nil, любое другое значение - истинно (в том числе 0 и пустая строка ""). Результатом выполнения and или or будет являться значение того операнда, который определил итоговое значение. То есть, если результат and/or понятен уже из значения первого операнда, то он и будет значением выражения. Если же потребовалось вычисление второго операнда, то значением выражения будет второй операнд. Таким образом:

- and даёт значение первого операнда, если он ложный, иначе - второго;
- or даёт значение первого операнда, если он истинный, иначе - второго.

```lua
print(5 and 8) --> 8
print(5 or 8) --> 5
print(nil and 5) --> nil
print(false or 5) --> 5
```

not же всегда даёт значение типа boolean, обратное истинности операнда.

```lua
print(not 0) --> false
print(not nil) --> true
```

Такое поведение операторов позволяет применять парочку интересных трюков с их использованием. Например, когда нужно установить переменной значение по умолчанию, если она равна nil, в большинстве случаев можно сделать так:

```lua
x = x or 5 -- если x не задан, установим его значение равным 5
```

Но стоит учесть, что такой приём неприменим, если false считается заданным корректным значением.

Другой трюк позволяет обойти проблему отсутствия в языке тернарного оператора, аналогичного a ? b : c из Си-образных языков:

```lua
result = a and b or c -- если a истинно, то result = b, иначе result = c
```

Здесь так же, как и в предыдущем случае, есть загвоздка: b не должно быть ложным (nil или false). Если b окажется ложным, то выражение в любом случае вернёт c, так как выражение (a and b) будет ложно.

В качестве примера, выбор максимального значения из двух выглядит так:

```lua
max = (x > y) and x or y
```

А определение знака числа можно записать так:

```lua
-- переносы строк вставлены для лучшей читаемости
-- на самом деле это одно выражение
sign = x < 0 and -1
    or x > 0 and 1
    or 0
```

Приоритет операторов чётко определён (от высшего к низшему):

```lua
^
not  #  - (унарный)
*   /   %
+   -
..
<   >   <=  >=  ~=  ==
and
or
```

То есть, если в сложном выражении используются операторы, располагающиеся на разных строках указанной таблицы, то они будут выполнены именно в этом порядке. Если вам нужно изменить порядок выполнения операторов (или если вы просто забыли, кто за кем следует), то используйте круглые скобки:

```lua
distanceSquared = (x1 - x2) ^ 2 + (y1 - y2) ^ 2
wtf = (a > b) and (a < c) -- чтоб наверняка
```

##### userdata

Как известно, Lua используется как язык, встраиваемый в другие приложения. Значение типа userdata - это просто кусок данных, переданный Lua-коду из основной программы. Сам язык не определяет никаких операций над этим типом, кроме присваивания и определения равенства/неравенства; любые другие операции реализуются разработчиком в приложении и предоставляются Lua-коду в виде функций. Тип userdata обычно используется для представления пользовательских типов данных. Например, используемые в фреймворке LÖVE объекты вроде Image, Source или SpriteBatch являются значениями типа userdata. Подробно останавливаться на этом типе не будем, так как он связан с API для взаимодействия с приложением, а это уже выходит за рамки введения.

#### Ещё про значения и их типы

TODO: может пруф найти на эту инфу?

Типы nil, number, string и boolean являются примитивными типами. Для значений таких типов справедливы следующие утверждения:

- они сравниваются "по смыслу", то есть, например, сравнение чисел производится ожидаемым с точки зрения математики образом, а строки считаются равными тогда и только тогда, когда они совпадают посимвольно;
- они неизменяемы (immutable), то есть, например, любая арифметическая операция над числами приводит к созданию нового числового значения, а присоединение одной строки к другой - к созданию новой строки;
- при присваивании производится копирование значения непосредственно в указанную переменную (за исключением типа string - см. примечание ниже).

Типы function, table, userdata и thread являются объектными типами, то есть, значения этих типов представляют собой указатели на некоторые объекты в памяти:

TODO: может "указатели" заменить на "идентификаторы"? уникальные значения, однозначно указывающие на объект в памяти

- при сравнении значений таких типов производится сравнение _указателей_ на объекты, а не самих объектов. Это означает, что два значения в этом случае будут равны, только если они являются указателями на один и тот же объект;
- объект может быть изменён (mutated) без изменения переменных, хранящих указатель на него;
- при присваивании копируется только указатель на объект, но не сам объект.

В следующей части эти свойства будут наглядно рассмотрены на примере таблиц.

TODO: (Да, слово "объект" здесь имеет слабое отношение к объектно-ориентированному программированию и несёт лишь тот смысл, что каждый объект является уникальным и имеет identity ("личность"))

Обратите внимание: присваивание не изменяет само значение, оно изменяет _переменную_, копируя в неё указанное значение. Да, по сути, присваивание всегда копирует значение, просто в случае объектных типов этим значением является указатель на объект.

Тип string является особенным касательно реализации. С точки зрения программиста строки ведут себя в точности как примитивные значения (они неизменяемы и сравниваются "по смыслу"), однако "внутри" они реализованы как указатель на последовательность байт, так что копирования содержимого строк при присваивании не происходит. Также имеет место оптимизация, называемая string interning: Lua при создании строк следит за тем, чтобы они хранились в памяти только в одном экземпляре. Если оказывается, что создаваемая строка уже существует в памяти, то используется уже имеющаяся. Таким образом экономится память, а сравнение строк происходит очень быстро, так как оно по сути сводится к сравнению указателей на память.

TODO: в puc-rio lua по-другому, может упомянуть?

Если вы знакомы с более низкоуровневыми языками программирования, заметьте, что вручную выделять память под объекты и строки, а также впоследствии очищать её не нужно, всё это делается автоматически. Объекты и строки, до которых нельзя добраться через доступные переменные, спустя некоторое время автоматически удаляются из памяти сборщиком мусора. Также, несмотря на то, что значения объектных типов являются указателями, выполнять арифметические операции над указателями нельзя.

Кстати, разницу между примитивными и объектными типами можно заметить, если попробовать вывести их в консоль при помощи print:

```lua
print(5) --> 5
print("i'm a string") --> i'm a string
print(true) --> true
print(nil) --> nil
print(print) --> function: 0x24d42a40
print(math) --> table: 0x24d42a90
```
