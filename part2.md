Таблица - единственный составной тип данных в Lua. Таблица представляет собой ассоциативный массив, то есть, она позволяет хранить значения и связанные с ними уникальные ключи, по которым эти значения можно получить. Таблицы используются в языке для многих целей и могут играть роль словарей, массивов, объектов, множеств и др.

```lua
obj = {} -- создание пустой таблицы
obj["color"] = "green" -- сохранение значения "green" под ключом "color"
obj["size"] = 5
print(obj["color"]) --> "green"
obj["color"] = "turquoise" -- заменяем значение по ключу "color" на другое
print(obj["color"]) --> "turquoise"
```

Как ключ, так и значение могут быть любых типов, кроме nil. Два ключа указывают на одно и то же значение только если они равны между собой (равенство определяется по тем же правилам, которые были описаны в первой части).

```lua
data = {}
data[5] = true
data["inner"] = {} -- "вложенные" таблицы тоже можно
key = {}
data[key] = "a value" -- таблицы тоже можно использовать в качестве ключей
```

При этом значение nil символизирует отсутствие данного значения в таблице. Это означает, что:

- обращение к несуществующему ключу даёт результат nil;
- установка значения nil для определённого ключа удаляет эту пару "ключ-значение" из таблицы.

```lua
print(data[6]) --> nil
data[5] = nil -- удаляем пару "[5] = true" из таблицы
```

Обращение по ключу nil всегда даёт результат nil. Попытка же сохранить значение под ключом nil приводит к ошибке.

Для обращения к строковым ключам, которые удовлетворяют правилам именования переменных, можно воспользоваться специальным синтаксисом, указав этот ключ через точку без кавычек:

```lua
dog = {}
dog["name"] = "Toby"
dog.breed = "Pomeranian"
print("Name: " .. dog.name .. " | Breed: " .. dog["breed"])
```

При каждом использовании литерала {} в памяти создаётся новая таблица. Так как table является объектным типом, вся работа с таблицами производится через указатели на них. Это означает, что:

- присваивание копирует только указатель на эту таблицу, но не саму таблицу;
- сравнение двух табличных значений заключается в сравнении указателей.

Из второго пункта следует, что конкретная таблица может быть равна только сама себе. Если же создать две таблицы, они никогда не будут равны, даже если их содержимое будет полностью совпадать. Иначе говоря, каждая таблица с точки зрения языка рассматривается как уникальный объект, а не как набор данных.

```lua
a = {}
b = {}
print(a == b) --> false - таблицы разные
c = a -- присваивание копирует только указатель, но не саму таблицу
print(a == c) --> true - обе переменные указывают на одну и ту же таблицу
c.value = 23
print(a.value) --> 23
```

Те же самые правила равенства действуют при использовании таблиц как ключей.

```lua
key1 = {}
key2 = {}

data = {}
data[key1] = "a"
data[key2] = "b"

print(data[key1]) --> "a"
print(data[key2]) --> "b"

print(data[{}]) --> nil

key1.x = 5 -- изменение содержимого таблицы не влияет на работу этой таблицы в качестве ключа
print(data[key1]) --> "a"
```

При создании таблицы можно сразу указать содержащиеся в ней значения (то есть, проинициализировать её):

TODO: сначала пример с квадратными скобками, а потом отдельно без них
TODO: ant = { legs = 6, isCarnivore = false, family = "Formicidae" }

```lua
data = {length = 5, type = "text", ["rotation"] = math.pi / 2, [20] = "idk", [2 + 3] = "haha"}
data.message = "Hello" -- конечно, после этого никто не мешает добавлять или удалять любые записи
```

Опять же, строковые ключи можно указывать без квадратных скобок и кавычек. Квадратные скобки же ожидают внутри себя выражение. То есть:

```lua
-- эти строки делают одно и то же
data = {dog = 5}
data = {["dog"] = 5}

-- не путать: здесь в качестве ключа используется значение, содержащееся в переменной dog
data = {[dog] = 5}
```

К слову, можно оставлять в конце висящую запятую. Это удобно, например, при генерации Lua-кода - не нужно обрабатывать последний элемент как особый случай. Также это позволяет проще менять местами строки при необходимости.

```lua
person = {
    firstName = "John",
    lastName = "Smith",
    gender = "Male",
}
```

Таблица может играть роль обычного массива. Для этого нужно просто использовать целые (а точнее - натуральные) числа в качестве ключей:

```lua
colors = {[1] = "red", [2] = "green", [3] = "blue"}
```

Для более простой инициализации таблиц, используемых в качестве массивов, есть возможность перечислить элементы в фигурных скобках без указания ключей. В этом случае значения сохранятся под целочисленными ключами, пронумерованные в том порядке, в котором они были указаны, начиная с единицы.

```lua
numbers = {2, 3, 5, 7, 11, 13, 17, 19}
print(numbers[5]) --> 11
```

Да, нумерация элементов производится с единицы. Спорный момент, особенно если учитывать, что само назначение языка подразумевает его взаимодействие с другими языками, где в качестве индексов традиционно используются смещения, начинающиеся с нуля. Но внутри языка это ощущается вполне естественно для человека: счёт производится с единицы, а номер последнего элемента равен их количеству. К тому же, это согласуется с используемыми в языке замкнутыми интервалами в циклах (о них в следующей части).

Конечно, такие таблицы могут содержать и ключи других типов, как любые другие таблицы. Смешивать два варианта инициализации тоже можно. Пример из официальной документации:

```lua
polyline = {color="blue", thickness=2, npoints=4,
             {x=0,   y=0},
             {x=-10, y=0},
             {x=-10, y=1},
             {x=0,   y=1}
           }
print(polyline[2].x)  --> -10
print(polyline.color) --> "blue"
```

Оператор # позволяет определить количество элементов в таблице, составляющих массив: он даёт номер элемента, после которого массив "обрывается". То есть, такое n, при котором t[n] ещё существует, а t[n + 1] уже nil. Общее же количество элементов в таблице так просто определить нельзя.

```lua
print(#numbers) --> 8
numbers[#numbers + 1] = 23 -- добавили девятый элемент, продолжив массив
print(#numbers) --> 9
numbers[11] = 31 -- "перепрыгнули" через элемент номер 10
print(#numbers) --> 9 - не изменилось
```

Заметьте, что если таких "дыр" в массиве несколько, то оператор может посчитать любую из них концом массива - поведение его в этом случае не определено. Так что массивы с дырами создавать крайне не рекомендуется. Если всё же требуется хранить в массиве некоторое значение, символизирующее отсутствие элемента, можно выделить под него особое значение, не равное nil и какому-либо другому значению. Например, таблицу:

```lua
hole = {}
numbers[4] = hole
print(numbers[4] == hole) --> true
```

В принципе, никто не мешает добавлять элементы вручную и нумеровать их хоть с нуля, хоть с минус восьми. Но как минимум оператор # вас не поймёт. И не только он, как будет видно позже.

Кстати, можно получить что-то похожее на многомерный массив, если использовать в качестве элементов таблицы другие таблицы:

```lua
matrix = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
}
print(matrix[2][3]) --> 6
```

Ещё один момент, касающийся массивов, который в принципе знать не обязательно, но не помешает. Если вас пугает, что такой тип данных, как ассоциативный массив, используется вместо обычного массива, где часто требуется быстрый доступ к элементам, можете быть спокойны: таблицы в Lua внутри состоят из двух частей - хеш-части и массивной части. Массивная часть реализована как обычный массив и хранит элементы с целочисленными ключами от 1 до некоторого n. Хеш-часть - хеш-таблица, которая хранит всё остальное. Размер каждой из частей увеличивается динамически, чтобы хранить требуемое количество элементов. Подробнее о реализации таблиц и о других тонкостях, связанных с производительностью, можно почитать [здесь](http://www.lua.org/gems/sample.pdf).

Таблицу можно также использовать в качестве множества (set), то есть, коллекции, содержащей уникальные значения и позволяющей быстро проверить наличие в ней какого-либо элемента. Для этого можно просто использовать нужные значения в качестве ключей таблицы, а вместо соответствующих им значений использовать любое истинное значение (например, true).

```lua
powerups = {}
powerups["doublejump"] = true
powerups["dash"] = true
```

Конечно, это далеко не всё, что можно делать с таблицами. В дальнейшем будут рассмотрены обход элементов таблицы, вспомогательные функции для работы с массивной частью и некоторые другие вещи.
