В этой части будет описано несколько важных инструкций языка Lua. Под инструкцией (statement) понимается некоторая самостоятельная часть программы, которую обычно пишут с новой строки. Например, из первой статьи читатель уже поверхностно знаком с двумя видами инструкций языка - присваиванием (=) и вызовом функции (на примере функции print).

Lua поддерживает следующие инструкции для управления потоком выполнения (иначе говоря, для изменения порядка выполнения инструкций):

* if-else
* while
* repeat-until
* numeric for
* generic for
* goto

В целом, они повторяют аналогичные конструкции из других языков. Особенной является только, пожалуй, generic for, но она во всей своей красе будет рассмотрена позже.

#### if-else

Инструкция if реализует ветвление, то есть позволяет выполнить тот или иной блок кода в зависимости от истинности некоторого условия.

```lua
if условие then
    блок
end
```

В качестве условия может выступать любое выражение. В качестве блока - любой набор инструкций. Всё как обычно: если условие истинно, то блок выполняется. Если нет, то нет (опять я переборщаю с подробностями, да?). Здесь, как и везде в Lua, применяются те же правила определения истинности выражения: любое значение, кроме false и nil, является истинным.

```lua
if hitpoints <= 0 then
    print("dead")
    lives = lives - 1
end
```

Заметьте, что присваивание в Lua не является выражением, как в Си-образных языках. И это правильно, ибо, говорят, новички иногда путают = и ==.

```lua
if lives = 0 then -- ошибка
    gameOver()
end
```

Конечно, можно дополнить if блоком else, который выполняется только в случае, если условие ложно:

```lua
if lives > 0 then
    restart()
else
    gameOver()
end
```

Если условий требуется несколько, можно воспользоваться elseif. Это аналогично ещё одному вложенному if в блоке else, но пишется короче. В результате выполняется только один из блоков. Пример из [PiL](http://www.lua.org/pil/4.3.1.html):

```lua
if op == "+" then
    r = a + b
elseif op == "-" then
    r = a - b
elseif op == "*" then
    r = a * b
elseif op == "/" then
    r = a / b
else
    error("invalid operation")
end
```

Инструкции switch из Си здесь нет. Скорее всего, авторы языка посчитали её избыточной, так как она слишком редко требуется и при необходимости может быть сымитирована средствами более общего назначения, например, тем же if-elseif-else.

#### while

```lua
while условие do
    блок
end
```

Инструкция while повторно выполняет блок кода до тех пор, пока истинно условие. Проверка условия производится перед очередным выполнением блока. Вот так, например, можно вывести [числа Фибоначчи](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%B0_%D0%A4%D0%B8%D0%B1%D0%BE%D0%BD%D0%B0%D1%87%D1%87%D0%B8), меньшие 100:

```lua
last = 0
current = 1

while current < 100 do
    print(current)
    last, current = current, last + current
end
```

#### repeat-until

```lua
repeat
    блок
until условие
```

repeat-until повторно выполняет блок кода до тех пор, пока условие не станет истинным. То есть, until - это по сути "while not". Ещё одно отличие от while - проверка условия производится *после* выполнения блока, так что блок выполняется в любом случае хотя бы один раз. Этим инструкция похожа на do-while из Си.

Логичнее всего эту инструкцию использовать в случае, если мы "стремимся" к выполнению условия: ждём правильного ответа, ищем нужный элемент и др.

```lua
print("Enter your name")

repeat
    name = io.stdin:read() -- считываем строку со стандартного потока ввода
until name ~= ""           -- пока имя, наконец, не введут

print("Hello, " .. name .. "!")
```

#### numeric for

Числовой цикл for позволяет шагать по числовым значениям из указанного диапазона. При этом в каждую итерацию указанная переменная-счётчик принимает соответствующее числовое значение.

```lua
for i = от, до, шаг do
    блок
end
```

Каждое из трёх выражений (от, до, шаг) должно принимать числовое значение. Выражения вычисляются только один раз, перед выполнением цикла. Обратите внимание, что как нижняя, так и верхняя границы включаются в диапазон.

```lua
-- выводит чётные числа в диапазоне от 4 до 20 включительно
for num = 4, 20, 2 do
    print(num)
end
```

Ни границы, ни шаг не обязаны быть целыми. Дробные числа будут работать так, как ожидается.

Шаг можно не указывать, тогда он принимается равным 1. Какой ещё есть популярный пример использования циклов, помимо чисел Фибоначчи? Конечно же, вычисление факториала!

```lua
n = 5
result = 1

for i = 2, n do
    result = result * i
end

print(n .. "! = " .. result)
```

Шаг может быть отрицательным, чтобы считать в обратную сторону, но тогда нужно указывать соответствующие "от" и "до", чтобы "от" было больше, иначе ни одной итерации не выполнится.

Споём песенку:

```lua
for bottles = 10, 2, -1 do
    print(bottles .. " green bottles standing on the wall,")
    print(bottles .. " green bottles standing on the wall,")
    print("And if one green bottle should accidentally fall,")

    if bottles > 2 then
        print("There'll be " .. bottles - 1 .. " green bottles standing on the wall.")
    else
        print("There'll be one green bottle standing on the wall.")
    end

    print() -- print без аргумента просто выводит пустую строку
end

print [[One green bottle standing on the wall,
One green bottle standing on the wall,
And if that green bottle should accidentally fall,
There'll be no more bottles standing on the wall.]]
```

Часто, если переменная-счётчик внутри цикла не используется, её называют _ (подчёркивание), чтобы это было сразу видно.

Числовой цикл можно использовать для инициализации или обхода элементов массивов:

```lua
squares = {}

for i = 1, 10 do
    squares[i] = i ^ 2
end

for i = 1, #squares do
    print(i, squares[i])
end
```

Для инициализации вложенных (многомерных) массивов можно использовать вложенные числовые циклы:

```lua
width = 30
height = 20
map = {}

for row = 1, height do
    map[row] = {}

    for column = 1, width do
        map[row][column] = 0
    end
end
```

#### generic for

generic (обобщённый) for - довольно мощная конструкция, которая позволяет совершать обход значений, генерируемых специально сформированной функцией. Более подробно generic for будет рассмотрен позже, а пока стоит ознакомиться с его использованием для обхода элементов таблицы. Для этого существуют стандартные функции ipairs и pairs.

##### ipairs

Функция ipairs используется для обхода "массивной" части таблицы.

```lua
todo = {"do the laundry", "call Petya", "finish the article"}

for i, v in ipairs(todo) do
    print(i, v)
end
```

Такой цикл перебирает все элементы с целочисленными ключами в порядке возрастания, начиная с единицы, до тех пор, пока не наткнётся на значение nil. При этом в две переменные, указываемые после слова "for", попадают номер элемента и его значение. Вторую переменную, кстати, можно не указывать, если она не нужна.

В отличие от конструкции с использованием числового for и оператора #, цикл с ipairs гарантированно останавливается перед первым nil. Поведение же оператора # на массивах с дырами не определено, как это было сказано в предыдущей части. Таким образом, на "недырявых" массивах разница будет проявляться разве что в производительности - цикл ipairs работает чуть медленнее (хотя и в большинстве случаев некритично). Зато выглядит он всё-таки покрасивее.

##### pairs

Функция pairs используется для обхода вообще всех элементов таблицы.

```lua
person = {firstName = "Alexander", lastName = "Pushkin", occupation = "writer"}

for k, v in pairs(person) do
    print(k, v)
end
```

Заметьте, что порядок обхода элементов таблицы в этом случае непредсказуем (даже для целочисленных ключей), и полагаться на него нельзя. Если всё же требуется иметь возможность обращаться к значениям по ключам и при этом обходить их в определённом порядке, то можно хранить эти ключи отдельно в виде массива в ещё одной таблице.

При обходе таблицы с использованием pairs можно без опаски удалять элементы из таблицы, присваивая им значение nil, и это не приведёт к тому, что какая-либо из существующих в таблице пар будет пропущена при обходе. Однако, добавление новых элементов в таблицу во время её обхода не рекомендуется, так как в этом случае поведение не определено.

```lua
-- bullets - таблица, содержащая в ключах пули, в данный момент отображаемые на экране
-- каждая "пуля" - уникальная таблица, содержащая координаты (x, y) и скорость (v)

for bullet in pairs(bullets) do
    bullet.y = bullet.y - bullet.v * dt

    if bullet.y < 0 then -- пуля ушла за край экрана
        bullets[bullet] = nil -- удаляем её из таблицы
    end
end
```

Кстати, если вы замечаете, что вам часто требуется определять наличие элемента в массиве, каждый раз пробегая циклом ipairs по всем элементам, или даже иногда удалять эти элементы из массива, то стоит подумать, действительно ли вам нужно хранить эти элементы в определённом порядке. Если вам не важен порядок, и элементы являются гарантированно уникальными, то гораздо эффективнее будет хранить их как ключи в таблице, используя в качестве значений любое истинное значение, как в примере выше.

Любой цикл (while, repeat-until, for) можно принудительно прервать, используя инструкцию break:

```lua
-- угадываем число
-- осторожно, много незнакомых функций

math.randomseed(os.time()) -- инициализируем генератор случайных чисел
number = math.random(100) -- генерируем случайное значение от 1 до 100

while true do -- бесконечный цикл
    io.write("your guess: ") -- используем write вместо print, чтобы не добавлялся перенос строки
    guess = io.read("*n") -- считываем число со стандартного потока ввода

    if guess > number then
        print("too big")
    elseif guess < number then
        print("too small")
    else
        break -- угадали, заканчиваем
    end
end

print("you're winner!")
```

А вот инструкции continue в языке нет. Придётся либо переорганизовывать код, чтобы в ней отпала необходимость, либо... использовать goto!

#### goto

Инструкция goto позволяет перепрыгнуть на другое место в коде. Для этого нужно указать в этом месте именованную метку.

```lua
print("test 1")
goto test3 -- прыгнуть на метку test3
print("test 2") -- не сработает
::test3:: -- метка
print("test 3")
```

Метка видна только в пределах блока, в котором она определена (и во вложенных в него блоках), то есть, нельзя прыгнуть в блок, который не включает в себя текущую инструкцию, с которой мы собрались прыгать.

Инструкция goto позволяет реализовать не только обычное continue, но даже вложенное continue или break, т.е. при использовании вложенных циклов прервать выполнение внешнего.

Пример [отсюда](http://lua-users.org/wiki/GotoStatement):

```lua
for z=1,10 do
for y=1,10 do
for x=1,10 do
  if x^2 + y^2 == z^2 then
    print('found a Pythagorean triple:', x, y, z)
    print('now trying next z...')
    goto zcontinue
  end
end end ::zcontinue:: end
```

В принципе, реальная необходимость в этой инструкции возникает нечасто. Я бы посоветовал ей не увлекаться, чтобы не превратить код в спагетти.
