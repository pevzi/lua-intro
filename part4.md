До сих пор при необходимости задействовать какую-либо переменную мы просто присваивали ей значение:

```lua
species = "hyena"
quantity = 3
```

При этом использовались так называемые глобальные переменные. Такие переменные видны отовсюду, то есть, к их значениям можно обращаться из любого места программы. Однако, например, переменная-счётчик из рассмотренного в прошлой статье числового цикла for таковой не является: её областью видимости является только блок внутри for. То есть:

```lua
for i = 1, 10 do
    print(i)
end

print(i) -- выводит nil, так как снаружи ту переменную в for не видно
```

Переменная, область видимости которой ограничена блоком кода, называется локальной для этого блока. Так, при использовании числового for автоматически объявляется локальная переменная-счётчик.

Локальную переменную можно объявить и вручную. При этом, пока ей не присвоится значение, она будет иметь значение nil.

```lua
if moving then
    local newX         -- можно отдельно объявить переменную
    newX = x + vx * dt -- и потом отдельно присвоить ей значение

    local newY = y + vy * dt -- а можно и то, и другое сразу

    if newX > width then
        -- во вложенных блоках локальные переменные, объявленные снаружи, тоже доступны
        newX = width -- изменяем значение локальной переменной newX, объявленной выше
    end
end

-- здесь эти переменные уже не видно
```

Также существует возможность создать блок безо всяких управляющих конструкций:

```lua
do
    local up, down, left, right -- кстати да, можно объявить несколько переменных сразу
end
```

Если во вложенном блоке объявить переменную с именем, которое уже занято какой-то другой переменной, объявленной снаружи, то новая переменная перекроет старую. Другими словами, при обращении к какой-либо переменной ищется ближайшая по глубине вложенности переменная с указанным именем. Если не нашлось ни одной локальной, то используется глобальная.

Пример из [официального руководства](http://www.lua.org/manual/5.3/manual.html#3.5):

```lua
x = 10                  -- глобальная переменная
do                      -- новый блок
    local x = x         -- новая переменная 'x', со значением 10
    print(x)            --> 10
    x = x + 1
    do                  -- новый блок
        local x = x + 1 -- новый 'x'
        print(x)        --> 12
    end
    print(x)            --> 11
end
print(x)                --> 10  (глобальный)
```

Если объявить локальную переменную вне всяких блоков, она будет локальной для данного файла. Да, строго говоря, в общем случае не для файла, а для [чанка](http://www.lua.org/pil/1.1.html) - куска кода, обрабатываемого "за раз". При работе с командной строкой Lua чанком будет являться одна введённая строка, а в случае исполнения файла целиком - весь файл. Кстати, разбиение программы на несколько файлов (модулей) будет рассмотрено позже.

Стоит, наверное, отметить, что "жизнь" переменной начинается именно с той строки, в которой её объявили. То есть, здесь не происходит неявного поднятия (hoisting) объявления переменной в начало блока, как в JavaScript при использовании var.

_Глобальные_ переменные обычно используются для предоставления разработчику некоторых стандартных функций языка и других средств для "общения с внешним миром". Например, переменные print, pairs, ipairs являются глобальными. В целом, хорошим тоном считается не создавать новые глобальные переменные без крайней необходимости, а объявлять и использовать локальные. На это есть как минимум три причины:

1. Обращение к локальным переменным происходит быстрее. При одном обращении это не так важно, но если глобальные переменные, например, используются в цикле, то негативный эффект может быть очень заметным.

2. В больших программах засорение глобального пространства имён вынуждает следить, чтобы все используемые глобальные переменные имели разные имена. Иначе это может привести к тому, что разный код будет конфликтовать, пытаясь обратиться к одним и тем же переменным. Лучше, когда каждый модуль работает в своём предсказуемом пространстве. Особенно это актуально при написании библиотек, которые подразумевают использование их другими людьми.

3. Читаемость кода: чем меньше область видимости у переменной, тем проще понять, где и для чего она используется. По этой же причине желательно объявлять переменную как можно ближе к её использованию вместо того, чтобы разом объявлять все используемые переменные в начале блока.

Ещё одна деталь. Из-за того, что обращение к неопределённым глобальным переменным не вызывает ошибки, следует быть внимательнее при указании имён переменных, так как при опечатке есть возможность "промахнуться" по нужной переменной и попасть в глобальную, которая равна nil. А это может обнаружиться не сразу и в неожиданном месте. Позже будет рассмотрен способ, изменяющий поведение языка в такой ситуации.

Кстати, ещё о глобальных переменных. Вы заметили, что неопределённые глобальные переменные ведут себя точно так же, как незаданные значения в таблицах? Они тоже изначально равны nil, и установка значения nil эквивалентна удалению элемента. Это совпадение на самом деле не случайно: значения всех глобальных переменных действительно хранятся в специальной таблице. Обратиться к этой таблице можно через переменную \_G:

```lua
foo = 5
print(_G.foo) --> 5

for k, v in pairs(_G) do
    print(k, v)
end
```
