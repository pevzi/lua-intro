До сих пор при необходимости задействовать какую-либо переменную мы просто присваивали ей значение:

```lua
species = "hyena"
quantity = 3
```

При этом использовались так называемые глобальные переменные. Такие переменные видны отовсюду, то есть, к их значениям можно обращаться из любого места программы. Однако, например, переменная-счётчик из рассмотренного в прошлой статье числового цикла for таковой не является: её областью видимости является только блок внутри for. То есть:

```lua
for i = 1, 10 do
    print(i)
end

print(i) -- выводит nil, так как снаружи ту переменную в for не видно
```

Переменная, область видимости которой ограничена блоком кода, называется локальной для этого блока. Так, при использовании числового for автоматически объявляется локальная переменная-счётчик.

Локальную переменную можно объявить и вручную. При этом, пока ей не присвоится значение, она будет иметь значение nil.

```lua
if moving then
    local newX         -- можно отдельно объявить переменную
    newX = x + vx * dt -- и потом отдельно присвоить ей значение

    local newY = y + vy * dt -- а можно и то, и другое сразу

    if newX > width then
        -- во вложенных блоках локальные переменные, объявленные снаружи, тоже доступны
        newX = width -- изменяем значение локальной переменной newX, объявленной выше
    end
end

-- здесь эти переменные уже не видно
```

Также существует возможность создать блок безо всяких управляющих конструкций:

```lua
do
    local up, down, left, right -- кстати да, можно объявить несколько переменных сразу
end
```

Если во вложенном блоке объявить переменную с именем, которое уже занято какой-то другой переменной, объявленной снаружи, то новая переменная перекроет старую. Другими словами, при обращении к какой-либо переменной ищется ближайшая по глубине вложенности переменная с указанным именем. Если не нашлось ни одной локальной, то используется глобальная.

Пример из [официального руководства](http://www.lua.org/manual/5.3/manual.html#3.5):

```lua
x = 10                  -- глобальная переменная
do                      -- новый блок
    local x = x         -- новая переменная 'x', со значением 10
    print(x)            --> 10
    x = x + 1
    do                  -- новый блок
        local x = x + 1 -- новый 'x'
        print(x)        --> 12
    end
    print(x)            --> 11
end
print(x)                --> 10  (глобальный)
```

Если объявить локальную переменную вне всяких блоков, она будет локальной для данного файла.

(Да, строго говоря, в общем случае не для файла, а для [чанка](http://www.lua.org/pil/1.1.html) - куска кода, обрабатываемого "за раз". При работе с командной строкой Lua чанком будет являться одна введённая строка, а в случае исполнения файла целиком - весь файл. Кстати, разбиение программы на несколько файлов (модулей) будет рассмотрено позже.)

Стоит, наверное, отметить, что "жизнь" переменной начинается именно с той строки, в которой её объявили. То есть, здесь не происходит неявного поднятия (hoisting) объявления переменной в начало блока, как в JavaScript при использовании var.

_Глобальные_ переменные обычно используются для предоставления разработчику некоторых стандартных функций языка и других средств для "общения с внешним миром". Например, переменные print, pairs, ipairs являются глобальными. В целом, хорошим тоном считается не создавать новые глобальные переменные без крайней необходимости, а объявлять и использовать локальные. На это есть как минимум три причины:

1. Обращение к локальным переменным происходит быстрее. При одном обращении это не так важно, но если глобальные переменные, например, используются в цикле, то негативный эффект может быть заметным.

2. В больших программах засорение глобального пространства имён вынуждает следить, чтобы все используемые глобальные переменные имели разные имена. Иначе это может привести к тому, что разный код будет конфликтовать, пытаясь обратиться к одним и тем же переменным. Лучше, когда каждый модуль работает в своём предсказуемом пространстве. Особенно это актуально при написании библиотек, которые подразумевают использование их другими людьми.

3. Читаемость кода: чем меньше область видимости у переменной, тем проще понять, где и для чего она используется. По этой же причине желательно объявлять переменную как можно ближе к её использованию вместо того, чтобы разом объявлять все используемые переменные в начале блока.

Ещё одна деталь. Из-за того, что обращение к неопределённым глобальным переменным не вызывает ошибки, следует быть внимательнее при указании имён переменных, так как при опечатке есть возможность "промахнуться" по нужной переменной и попасть в глобальную, которая равна nil. А это может обнаружиться не сразу и в неожиданном месте.

_Дополнительная информация для любознательных._ Тут может появиться закономерный вопрос: если именно локальные переменные считаются более предпочтительными в большинстве случаев, то почему тогда переменные создаются глобальными "по умолчанию", а для объявления локальной переменной требуется использовать дополнительное слово local? Вроде, логичнее было бы наоборот, как это сделано, например, в Python. Там присваивание к необъявленной переменной автоматически объявляет её как локальную, а для объявления глобальной переменной существует ключевое слово global.

Одна из [причин](http://lua-users.org/wiki/LocalByDefault) такого решения в Lua заключается в лучшей читаемости кода. Без явных указаний, что происходит объявление локальной переменной, трудно сказать, глядя на код, для какого именно блока переменная является локальной. Инструкция присваивания в этом случае может как изменять существующую переменную с целью повлиять на внешний код, так и объявлять новую локальную переменную, использующуюся только внутри этого блока. Явная же инструкция local позволяет видеть, что жизнь переменной начинается именно здесь.

Другая, более серьёзная проблема возникает при попытке изменить во вложенном блоке значение внешней переменной простым присваиванием. Если инструкция присваивания включает в себя объявление переменной, то в этом случае она без спроса объявляет ещё одну локальную переменную с тем же именем, чем нарушает наши планы (и, как следствие, требуется дополнительный костыль для явного изменения значения внешней переменной, вроде nonlocal в Python). Ещё есть вариант - допустить, чтобы при существовании внешней переменной с указанным именем язык обращался к ней, а не объявлял новую. Но в этом случае всё равно потребовалось бы ключевое слово для явного объявления переменной, чтобы была возможность при необходимости принудительно перекрыть существующую переменную. А если такое слово ввести, то все эти сложности с совмещённым присваиванием и объявлением снова перестают иметь смысл.

В общем, явное объявление локальных переменных показалось разработчикам языка более приемлемым вариантом. Другой вопрос в том, правильным ли было решение создавать глобальные переменные по умолчанию и отдавать nil при обращении к несуществующей переменной. Ведь именно возможность случайно "выпасть" в глобальную переменную беспокоит больше всего. Однако, к счастью, в этом отношении поведение языка можно при необходимости изменить. Этот трюк будет рассмотрен в одной из следующих статей.
