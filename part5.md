Естественно, в языке есть возможность обособить какой-либо кусок кода в сущность, называемую функцией. В Lua функция является значением типа function и, как любое другое значение, может быть присвоена переменной.

```lua
-- создание функции с помощью выражения function и присваивание её переменной
greet = function ()
    print("Hello")
end

-- то же самое, но с использованием инструкции, а не выражения
function greet()
    print("Hello")
end

-- эта инструкция делает то же самое, но перед созданием функции и
-- присваиванием объявляет локальную переменную с нужным именем
local function greet()
    print("Hello")
end
```

Чтобы исполнить "содержащийся" в функции код, её нужно вызвать, используя круглые скобки:

```lua
greet() --> "Hello"
```

Функция может отдавать результаты своей работы в виде возвращаемых значений. Чтобы получить эти значения, необходимо использовать вызов функции там, где ожидается выражение.

```lua
local function getAnswer()
    return 42
end

print(getAnswer() * 2) --> 84
```

Инструкция return завершает выполнение функции, возвращая управление вызвавшему её коду и передавая туда указанные значения. return можно использовать и без указания значений, если требуется раньше времени выйти из функции.

К слову, такой ранний выход из функции бывает полезен, когда функция не должна ничего делать при определённых условиях. Например:

```lua
local function doStuff()
    if active then
        -- тут куча строк
    end
end
```

Вместо того, чтобы всю эту кучу строк писать на вложенном уровне, нагляднее будет в начале функции проверить требуемое условие и завершить функцию, если оно не выполняется:

```lua
local function doStuff()
    if not active then
        return
    end

    -- тут куча строк
end
```

Особенно это улучшает читабельность, когда таких условий несколько, и при невыполнении каждого из условий нужно что-то сделать (например, сообщить об этом пользователю).

Кстати, интересная особенность return заключается в том, что его можно использовать только в самом конце блока. Конечно, return в середине блока особого смысла и не имеет (ведь последующие строки всё равно не выполнятся), но то, что это запрещено синтаксисом языка, само по себе довольно необычно.

Функции в Lua умеют возвращать несколько значений (и их на самом деле будет несколько, они не упаковываются в какой-нибудь tuple, как в Python). Чтобы получить все значения, нужно использовать вызов функции там, где ожидается несколько выражений, указанных через запятую.

```lua
local function foo()
    return 3, 4, 5
end

local a, b, c = foo() -- работает, как если бы эти три значения были просто указаны тут через запятую
```

Как это обычно бывает при множественном присваивании, те переменные, которым не хватило значений, принимают значение nil, а лишние значения отбрасываются.

Вызов функции можно использовать и в табличном литерале. Тогда возвращаемые оттуда значения воспринимаются, опять же, как просто перечисленные через запятую:

```lua
local numbers = {1, 2, foo()} -- {1, 2, 3, 4, 5}
print(numbers[4]) --> 4
```

Однако, обратите внимание, что если после вызова функции указаны другие элементы, то берётся только первое возвращаемое значение, а остальные отбрасываются.

```lua
local oops = {1, 2, foo(), 6, 7} -- {1, 2, 3, 6, 7}
print(oops[4]) --> 6
```

Другой случай, когда из функции берётся только одно возвращаемое значение, - использование функции в выражении.

```lua
print(foo() * 2) --> 6

-- если нужно принудительно отбросить все значения, кроме первого, можно взять вызов функции в круглые скобки
print((foo())) --> 3
```

Как это было видно на примере функции print(), функция может принимать в качестве входных данных одно или несколько значений, называемых аргументами функции. Как и в других языках, имена переменных для требуемых аргументов перечисляются через запятую в круглых скобках при определении функции. При вызове функции же в круглых скобках указываются соответствующие значения, "поступающие на вход".

```lua
local function sign(x)
    if x > 0 then
        return 1
    elseif x < 0 then
        return -1
    else
        return 0
    end
end

print(sign(-16)) --> -1

local function lerp(a, b, amount)
    return a + (b - a) * amount
end

print(lerp(3, 7, 0.375)) --> 4.5
```

Таким образом, по сути, происходит присваивание переданных значений соответствующим локальным переменным. И здесь при несовпадении количества требуемых и переданных аргументов работает то же знакомое правило:

```lua
local function bar(a, b, c)
    print(a, b, c)
end

bar(1, 2) --> 1 2   nil
bar("w", "x", "y", "z") --> "w" "x" "y"
```

Ну, и тут сама напрашивается возможность напрямую использовать возвращаемые из функции значения в качестве аргументов при вызове другой функции. И эта возможность есть:

```lua
bar(foo()) --> 3    4   5
```

Но здесь действует то же ограничение, что и при использовании функций в табличных литералах:

```lua
bar(foo(), 6, 7) --> 3  6   7
```

TODO: variadic (...)

Кстати, если в функцию нужно передать только один строковый или табличный аргумент в виде литерала (т.е. не переменной, а константой), при вызове функции круглые скобки можно не писать:

```lua
local function poke(name)
    print("Hey, " .. name .. "!")
end

poke "pevzi" --> "Hey, pevzi!"

local function printVector(v)
    print("x: " .. v.x, "y: " .. v.y)
end

printVector {x = 2, y = 3} --> "x: 2"   "y: 3"
```

- таблица в качестве аргумента вместо именованных
- unpack?
- рекурсия
  - объявление через local function foo() позволяет функции обращаться к самой себе
- функции высшего порядка
- замыкания
  - upvalues
- вызов методов через :
  - точка или двоеточие ставятся только после имени переменной или после закрывающей круглой скобки, так что, например, для вызова метода строки её необходимо взять в круглые скобки
- tail calls
  - http://www.lua.org/pil/6.3.html
- инструкцию определения функции нельзя использовать как выражение
