Естественно, в языке есть возможность обособить какой-либо кусок кода в сущность, называемую функцией. В Lua функция является значением типа function и, как любое другое значение, может быть присвоена переменной.

```lua
-- создание функции с помощью выражения function и присваивание её переменной
greet = function ()
    print("Hello")
end

-- то же самое, но с использованием инструкции, а не выражения
function greet()
    print("Hello")
end

-- эта инструкция делает то же самое, но перед созданием функции и
-- присваиванием объявляет локальную переменную с нужным именем
local function greet()
    print("Hello")
end
```

Чтобы исполнить "содержащийся" в функции код, её нужно вызвать, используя круглые скобки:

```lua
greet() --> "Hello"
```

#### Возвращаемые значения

Функция может отдавать результаты своей работы в виде возвращаемых значений. Чтобы получить эти значения, необходимо использовать вызов функции там, где ожидается выражение.

```lua
local function getAnswer()
    return 42
end

print(getAnswer() * 2) --> 84
```

Инструкция return завершает выполнение функции, возвращая управление вызвавшему её коду и передавая туда указанные значения. return можно использовать и без указания значений, если требуется раньше времени выйти из функции. Если инструкции return в функции нет, то return как бы неявно автоматически добавляется в самом конце - функция заканчивает своё выполнение и никаких значений не возвращает.

К слову, ранний выход из функции бывает полезен, когда функция не должна ничего делать при определённых условиях. Например:

```lua
local function doStuff()
    if active then
        -- тут куча строк
    end
end
```

Вместо того, чтобы всю эту кучу строк писать на вложенном уровне, нагляднее будет в начале функции проверить требуемое условие и завершить функцию, если оно не выполняется:

```lua
local function doStuff()
    if not active then
        return
    end

    -- тут куча строк
end
```

Особенно это улучшает читабельность, когда таких условий несколько, и при невыполнении каждого из условий нужно что-то сделать (например, сообщить об этом пользователю).

Кстати, интересная особенность return заключается в том, что его можно использовать только в самом конце блока. Конечно, return в середине блока особого смысла и не имеет (ведь последующие строки всё равно не выполнятся), но то, что это запрещено синтаксисом языка, само по себе довольно необычно.

Функции в Lua умеют возвращать несколько значений (и их на самом деле будет несколько, они не упаковываются в какой-нибудь цельный tuple, как в Python). Чтобы получить все значения, нужно использовать вызов функции там, где ожидается несколько выражений, указанных через запятую. Например, в присваивании:

```lua
local function foo()
    return 3, 4, 5
end

local a, b, c = foo() -- работает, как если бы эти три значения были просто указаны тут через запятую
```

Как это обычно бывает при множественном присваивании, те переменные, которым не хватило значений, принимают значение nil, а лишние значения отбрасываются.

Вызов функции можно использовать и в табличном литерале. Тогда возвращаемые оттуда значения воспринимаются, опять же, как просто перечисленные через запятую:

```lua
local numbers = {1, 2, foo()} -- {1, 2, 3, 4, 5}
print(numbers[4]) --> 4
```

Однако, обратите внимание, что если после вызова функции указаны другие элементы, то берётся только первое возвращаемое значение, а остальные отбрасываются.

```lua
local oops = {1, 2, foo(), 6, 7} -- {1, 2, 3, 6, 7}
print(oops[4]) --> 6
```

Другой случай, когда из функции берётся только одно возвращаемое значение, - использование вызова функции в выражении.

```lua
print(foo() * 2) --> 6

-- если нужно принудительно отбросить все значения, кроме первого, можно взять вызов функции в круглые скобки
-- это будет считаться за использование вызова функции в выражении
print((foo())) --> 3
```

#### Аргументы

Как это было видно на примере функции print(), функция может принимать в качестве входных данных одно или несколько значений, называемых аргументами функции. Как и в других языках, имена переменных для требуемых аргументов перечисляются через запятую в круглых скобках при определении функции. При вызове функции же в круглых скобках указываются соответствующие значения, "поступающие на вход".

```lua
local function sign(x)
    if x > 0 then
        return 1
    elseif x < 0 then
        return -1
    else
        return 0
    end
end

print(sign(-16)) --> -1

local function lerp(a, b, amount)
    return a + (b - a) * amount
end

print(lerp(3, 7, 0.375)) --> 4.5
```

Таким образом, по сути, происходит присваивание переданных значений соответствующим локальным переменным. И здесь при несовпадении количества требуемых и переданных аргументов работает то же знакомое правило:

```lua
local function bar(a, b, c)
    print(a, b, c)
end

bar(1, 2) --> 1 2   nil
bar("w", "x", "y", "z") --> "w" "x" "y"
```

Ну, и тут сама напрашивается возможность напрямую использовать возвращаемые из функции значения в качестве аргументов при вызове другой функции. И эта возможность есть:

```lua
bar(foo()) --> 3    4   5
```

Но здесь действует то же ограничение, что и при использовании функций в табличных литералах:

```lua
bar(foo(), 6, 7) --> 3  6   7
```

TODO: почему так

Также существует возможность создать функцию, которая принимает неопределённое количество аргументов. Например, таковой является используемый нами print - он выводит в консоль все значения, которые ему передают. Такие функции называются функциями с переменным числом аргументов и создаются следующим образом:

```lua
local function log(level, ...)
    local date = os.date() -- текущие дата и время
    print(level, date, ...) -- направляем в функцию print попавшие в многоточие аргументы
end

log("warning", "file does not exist", "story.txt") -- "warning" идёт в level, остальные два аргумента - в многоточие
```

По сути, многоточие заменяет собой переданные в функцию значения, перечисленные через запятую, и может использоваться там, где требуется выражение или несколько выражений (с теми же самыми правилами, описанными выше для функций, возвращающих несколько значений). В списке аргументов при определении функции многоточие обязательно должно быть последним (либо единственным).

```lua
local function wtf(...)
    local args = {...}
    local first, second = ...
    local x = ... * 5

    print(..., "a")
    print(first, second, x)
    print((...))
end
```

Кстати, если в функцию нужно передать только один строковый или табличный аргумент в виде литерала (т.е. не переменной, а константой), при вызове функции круглые скобки можно не писать:

```lua
local function poke(name)
    print("Hey, " .. name .. "!")
end

poke "pevzi" --> "Hey, pevzi!"

local function printVector(v)
    print("x: " .. v.x, "y: " .. v.y)
end

printVector {x = 2, y = 3} --> "x: 2"   "y: 3"
```

Строки без круглых скобок для улучшения читабельности часто используют при вызове функции require, которая будет рассмотрена в одной из следующих статей. Использование табличного литерала для вызова функции может быть полезно, например, в следующем случае.

В некоторых языках существует возможность при вызове функции указать значения отдельных конкретных аргументов по их имени, игнорируя все остальные. Особенно это удобно при использовании функций, принимающих относительно много необязательных аргументов. Lua не позволяет указывать значения аргументов по их именам, но в нём можно добиться того же поведения, просто используя таблицу в качестве аргумента.

Снова пример из [PiL](http://www.lua.org/pil/5.3.html):

```lua
w = Window{ x=0, y=0, width=300, height=200,
            title = "Lua", background="blue",
            border = true
          }
```

При этом сама функция может проверить наличие значений обязательных аргументов, а необязательным присвоить значения по умолчанию, если другого значения не было указано:

```lua
function Window (options)
  -- проверяем обязательные параметры
  if type(options.title) ~= "string" then
    error("no title")
  elseif type(options.width) ~= "number" then
    error("no width")
  elseif type(options.height) ~= "number" then
    error("no height")
  end

  -- остальные опциональны
  _Window(options.title,
          options.x or 0,    -- значение по умолчанию
          options.y or 0,    -- значение по умолчанию
          options.width, options.height,
          options.background or "white",   -- значение по умолчанию
          options.border      -- значение по умолчанию ложно (nil)
         )
end
```

Так как функции являются значениями, их тоже можно передавать в качестве аргументов в другие функции.

```lua
local function imap(t, f, ...)
    local result = {}

    for i, v in ipairs(t) do
        result[i] = f(v, ...)
    end

    return result
end

local squares = imap({5, 6, 7, 8, 9, 10}, function (v) return v ^ 2 end)

for i, v in ipairs(squares) do
    print(i, v)
end
```

#### Замыкания

Наверное, самая сложная часть этой статьи. Знать об этой возможности не обязательно, но иногда бывает полезно.

Функция может быть создана внутри любого блока, даже внутри другой функции. И, конечно, функция может обращаться к локальным переменным, объявленным вне её. Когда обе этих возможности объединяются, образуется интересная ситуация.

Рассмотрим пример:

```lua
local function makeGreeter(name)
    local text = "Hello, " .. name
    local function greet()
        print(text)
    end
    greet()
end

makeGreeter("Bob") --> "Hello, Bob"
```

makeGreeter создаёт функцию greet, которая приветствует указанную личность. Заметьте, что эта внутренняя функция обращается к переменной text, локальной для makeGreeter, т.е. объявленной вне greet. Если вызвать greet внутри makeGreeter, всё работает так, как ожидается. Но что будет, если вернуть эту функцию из makeGreeter и вызвать её уже снаружи?

```lua
local function makeGreeter(name)
    local text = "Hello, " .. name
    return function ()
        print(text)
    end
end

local greet = makeGreeter("Bob")
greet() -- ?
```

В данном примере после завершения makeGreeter созданная внутри неё функция продолжает жить снаружи в переменной greet. Получается, что при попытке вызова greet() она должна обратиться к переменной text, которой уже не должно существовать (ведь к тому времени уже произойдёт выход из содержавшего её блока). Однако, несмотря на это, такой код тоже работает и успешно приветствует Боба.

Дело в том, что Lua поддерживает механизм так называемых замыканий. Проще говоря, этот механизм позволяет "продлить жизнь" тем переменным, к которым обращаются какие-либо функции, созданные внутри области видимости этих переменных. Так, в нашем примере переменная text, конечно, не будет доступна напрямую по имени вне makeGreeter, но функция greet может продолжать работать с ней как ни в чём не бывало, так как на момент создания функции greet у неё имелся доступ к этой переменной.

Ещё раз: то, какие переменные будут доступны функции, определяется не тем, где функция вызывается, а тем, где она создаётся, т.е. тем, где непосредственно в коде располагается инструкция/выражение function. Это называется lexical scoping (лексическая область видимости). Сам термин "замыкание" используется по отношению к такой функции, "привязанной" ко внешним локальным переменным.

(_Примечание для любознательных._ Строго говоря, любое значение типа function в Lua является замыканием, где под замыканием понимается сущность, объединяющая в себе код функции, используемые ей внешние локальные переменные, а также [окружение](http://www.lua.org/pil/14.html). Код функции компилируется только один раз при обработке исходного текста программы и используется для всех экземпляров этой функции. Но новое замыкание создаётся каждый раз при выполнении инструкции/выражения function. При этом создание замыкания заключается в привязке кода функции к внешним локальным переменным и окружению. Это отличает функции в Lua от функций, например, в C, где указатель на функцию - это указатель только на код функции, но не на информацию о том, в каких "условиях" функция должна исполняться.)

Замыкание может использоваться для создания функции с некоторыми фиксированными параметрами. Простейший случай, классический пример:

```lua
local function makeAdder(a)
    return function (b)
        return a + b
    end
end

local add5 = makeAdder(5)
print(add5(4)) --> 9
```

Более интересный пример можно увидеть [тут](https://github.com/pevzi/cups/blob/0a4de606b77e8b9b8987800020b5e1bc1059fc1f/entities/fieldview.lua#L37).

Замыкание может даже модифицировать переменные. В результате получается, что функция как бы хранит некоторое скрытое состояние между своими вызовами.

```lua
local function makeCounter()
    local i = 0
    return function ()
        i = i + 1
        return i
    end
end

local count = makeCounter()
print(count()) --> 1
print(count()) --> 2
print(count()) --> 3
```

Заметьте, что каждое выполнение инструкции local объявляет новую локальную переменную, а каждое выполнение инструкции или выражения function создаёт новое замыкание. Таким образом, повторный вызов makeCounter приводит к созданию _другой_ переменной i и _ещё одного_ замыкания:

```lua
local count2 = makeCounter()

print(count2()) --> 1
print(count2()) --> 2

print(count()) --> 4
print(count()) --> 5

print(count2()) --> 3
```

Видно, что функции count и count2 замыкаются на две разные независимые переменные.

Можно создать несколько замыканий, использующих одни и те же переменные:

```lua
local function make(initial)
    local value = initial or 0
    local function get()
        return value end
    local function set(newValue)
        value = newValue
    end
    return get, set
end

local getX, setX = make()

setX(50)
print(getX()) --> 50
```

Здесь getX и setX работают с одной и той же переменной value, так что они видят результаты работы друг друга. Ещё один вызов функции make создаст другую пару функций, "связанных" уже другой переменной value. Такой подход позволяет хранить некоторое скрытое состояние и предоставлять набор функций для работы с ним.

Ещё одно полезное применение замыканий: функции, изменяющие некоторые внешние переменные, можно передавать в качестве аргументов там, где требуется callback (функция обратного вызова). При вызове такой функции произойдёт предсказуемое изменение требуемых переменных вне зависимости от того, где будет совершён её вызов.

Замыкания можно создавать не только внутри другой функции, но и внутри любого другого блока, например, в цикле:

```lua
local funcs = {}

for i = 1, 10 do -- каждую итерацию объявляется новая переменная i
    funcs[i] = function () return i end
end

for _, func in ipairs(funcs) do
    print(func())
end
```

Ну и, наконец, про сборку мусора. Так как при существовании замыкания переменная по сути тоже продолжает существовать, эта переменная так же считается ссылкой на значение, как и любая другая. Таким образом, значение не будет удалено из памяти, пока существуют замыкания, "ссылающиеся" на него.

#### Рекурсия

Функции могут вызывать сами себя (что известно как рекурсия):

```lua
local function factorial(n)
    if n < 0 then
        error("n must be non-negative")
    end

    if n == 0 then
        return 1
    end

    return factorial(n - 1) * n
end
```

При этом учтите, что следующая запись не заработает так, как ожидается:

```lua
local countdown = function (n) -- обратите внимание на эту строку
    if n <= 0 then
        return
    end

    print(n)

    return countdown(n - 1) -- ошибка: попытка вызвать значение nil
end

countdown()
```

Дело в том, что объявление локальной переменной countdown и присваивание происходят уже после создания функции. Поэтому на момент создания функции локальная переменная countdown ещё не объявлена, и обращение к countdown внутри функции запоминается, как обращение к глобальной переменной countdown. В итоге функция пытается вызвать то, что лежит в глобальной переменной countdown. В нашем случае там ничего не лежало, но могло. Чтобы исправить это недоразумение, можно воспользоваться инструкцией local function:

```lua
local function countdown(n) -- другое дело
    if n <= 0 then
        return
    end

    print(n)

    return countdown(n - 1)
end
```

Эта инструкция, по сути, аналогична следующей записи:

```lua
local countdown
countdown = function (n)
    if n <= 0 then
        -- и т.д.
```

Таким образом, на момент создания функции локальная переменная countdown уже будет существовать, и функция замкнётся уже на ней. Теперь всё работает как ожидалось.

##### Tail call

Есть и ещё одна тонкость при использовании рекурсии. Если точнее, то она может дать о себе знать и при вызовах других функций, но именно при рекурсии с ней столкнуться проще всего.

Речь идёт о переполнении стека. При вызове функции языку необходимо сохранить в памяти некоторую информацию о том, в какое место в коде нужно вернуться после завершения выполнения функции. Эта информация сохраняется в стеке. При выходе из функции эта информация оттуда извлекается и удаляется, а выполнение кода продолжается с соответствующей позиции. Если же та вызванная функция в свою очередь вызывает что-то ещё, то в стек добавляется ещё одна запись. Таким образом, если таких вложенных вызовов будет достаточно много, размер данных в стеке может превысить допустимый. Пронаблюдать эффект можно на примере функции для вычисления факториала, указанной выше, если попробовать вычислить значение факториала какого-нибудь большого числа - через некоторое время вычислений вылезет ошибка stack overflow.

Однако, в языке Lua (точнее, в его реализациях) есть решение этой проблемы. Когда вызов функции производится в самом-самом конце другой функции, никакой информации "о возврате" не записывается, ведь возвращаться в предыдущую функцию уже не нужно, больше там делать нечего. В результате при вызове функции происходит просто прыжок в неё без заполнения стека лишней информацией. Такая оптимизация называется tail call (хвостовой вызов).

Так, например, функция countdown удовлетворяет этому условию, поэтому переполнения стека она не вызовет при любом значении n. А вот factorial после вызова factorial(n - 1) требует ещё и умножения результата на n, так что после выполнения функции нужно туда вернуться и выполнить умножение.

Таким образом, в следующих [примерах](http://www.lua.org/pil/6.3.html) хвостового вызова не происходит:

```lua
return g(x) + 1  -- нужно произвести сложение
return x or g(x) -- требуется отбросить все возвращаемые значения, кроме первого
return (g(x))    -- то же самое
```

Ещё один неочевидный пример, в котором оптимизация не производится:

```lua
local function f(x)
    g(x)
end
```

Здесь загвоздка в том, что после вызова g(x) требуется отбросить лишние значения, которые могут быть возвращены функцией. Таким образом, единственная форма вызова, которая позволяет провести tail call оптимизацию, в общем случае выглядит так:

```lua
return f(аргументы)
```

При этом как f, так и любой из аргументов может быть сложным выражением, так как их значения вычисляются перед вызовом функции. Например, следующий вызов будет являться хвостовым:

```lua
return x[i].foo(x[j] + a*b, i + j)
```

Как можно переписать функцию, вычисляющую факториал, чтобы она использовала рекурсию, но не заполняла стек? Например, так:

```lua
local function factorial(n)
    if n < 0 then
        error("n must be non-negative")
    end

    local function fact(n, res)
        if n == 0 then
            return res
        end

        return fact(n - 1, res * n)
    end

    return fact(n, 1)
end
```

А, и ещё стоит учесть, что при tail call оптимизации может несколько затрудниться отладка ввиду отсутствия в стеке информации о вызове функций.

#### Определение и вызов методов

Допустим, у нас есть таблица player, хранящая текущие характеристики игрока, и функция healPlayer для того, чтобы восстановить его здоровье на указанное количество пунктов:

```lua
local player = {x = 10, y = 5, health = 80}

local function healPlayer(player, amount)
    player.health = math.min(player.health + amount, 100)
end

healPlayer(player, 10)
print(player.health) --> 90
```

В такой записи неудобно то, что между объектом player и функцией healPlayer нет никакой явной связи. Если потребуется передать куда-то игрока, то придётся как-то отдельно дать доступ и к функции healPlayer, чтобы там могли знать, как его лечить.

Вместо того, чтобы хранить эту функцию в отдельной локальной переменной, можно сохранить её в самой таблице player в качестве значения под ключом heal. Тогда можно получить что-то похожее на объект с методами, т.е. сущность, объединяющую в себе и данные, и функции для работы с ними:

```lua
local player = {x = 10, y = 5, health = 80}

function player.heal(self, amount)
    self.health = math.min(self.health + amount, 100)
end

player.heal(player, 30)
print(player.health) --> 100
```

Но это всё равно как-то некрасиво - нам приходится вручную передавать в функцию сам же объект в качестве аргумента, чтобы иметь возможность обратиться к его данным. Lua предоставляет специальный синтаксис для более простого определения и вызова таких функций - двоеточие:

```lua
local player = {x = 10, y = 5, health = 80}

function player:heal(amount)
    self.health = math.min(self.health + amount, 100)
end

player:heal(30)
print(player.health) --> 100
```

Теперь это больше похоже на метод. При определении функции двоеточие просто добавляет невидимый первый аргумент self, а при вызове - передаёт в качестве первого аргумента значение, стоящее слева от двоеточия. В результате переменная self внутри функции ссылается на сам объект. Таким образом, последние два примера работают совершенно одинаково, просто записаны по-разному.

Главное - не забывать ставить двоеточие вместо точки, когда вызываете методы, потому что тексты ошибок в этом случае обычно не особо поясняют суть того, что пошло не так (в лучшем случае - что-то вроде "произошла попытка проиндексировать число self").

В дальнейшем будут рассмотрены механизмы, которые позволяют реализовать другие привычные концепции объектно-ориентированного программирования.
