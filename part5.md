Естественно, в языке есть возможность обособить какой-либо кусок кода в сущность, называемую функцией. В Lua функция является значением типа function и, как любое другое значение, может быть присвоена переменной.

```lua
-- создание функции с помощью выражения function и присваивание её переменной
greet = function ()
    print("Hello")
end

-- то же самое, но с использованием инструкции, а не выражения
function greet()
    print("Hello")
end

-- эта инструкция делает то же самое, но перед созданием функции и
-- присваиванием объявляет локальную переменную с нужным именем
local function greet()
    print("Hello")
end
```

Чтобы исполнить "содержащийся" в функции код, её нужно вызвать, используя круглые скобки:

```lua
greet() --> "Hello"
```

#### Возвращаемые значения

Функция может отдавать результаты своей работы в виде возвращаемых значений. Чтобы получить эти значения, необходимо использовать вызов функции там, где ожидается выражение.

```lua
local function getAnswer()
    return 42
end

print(getAnswer() * 2) --> 84
```

Инструкция return завершает выполнение функции, возвращая управление вызвавшему её коду и передавая туда указанные значения. return можно использовать и без указания значений, если требуется раньше времени выйти из функции. Если инструкции return в функции нет, то return как бы неявно автоматически добавляется в самом конце - функция заканчивает своё выполнение и никаких значений не возвращает.

К слову, ранний выход из функции бывает полезен, когда функция не должна ничего делать при определённых условиях. Например:

```lua
local function doStuff()
    if active then
        -- тут куча строк
    end
end
```

Вместо того, чтобы всю эту кучу строк писать на вложенном уровне, нагляднее будет в начале функции проверить требуемое условие и завершить функцию, если оно не выполняется:

```lua
local function doStuff()
    if not active then
        return
    end

    -- тут куча строк
end
```

Особенно это улучшает читабельность, когда таких условий несколько, и при невыполнении каждого из условий нужно что-то сделать (например, сообщить об этом пользователю).

Кстати, интересная особенность return заключается в том, что его можно использовать только в самом конце блока. Конечно, return в середине блока особого смысла и не имеет (ведь последующие строки всё равно не выполнятся), но то, что это запрещено синтаксисом языка, само по себе довольно необычно.

Функции в Lua умеют возвращать несколько значений (и их на самом деле будет несколько, они не упаковываются в какой-нибудь цельный tuple, как в Python). Чтобы получить все значения, нужно использовать вызов функции там, где ожидается несколько выражений, указанных через запятую.

```lua
local function foo()
    return 3, 4, 5
end

local a, b, c = foo() -- работает, как если бы эти три значения были просто указаны тут через запятую
```

Как это обычно бывает при множественном присваивании, те переменные, которым не хватило значений, принимают значение nil, а лишние значения отбрасываются.

Вызов функции можно использовать и в табличном литерале. Тогда возвращаемые оттуда значения воспринимаются, опять же, как просто перечисленные через запятую:

```lua
local numbers = {1, 2, foo()} -- {1, 2, 3, 4, 5}
print(numbers[4]) --> 4
```

Однако, обратите внимание, что если после вызова функции указаны другие элементы, то берётся только первое возвращаемое значение, а остальные отбрасываются.

```lua
local oops = {1, 2, foo(), 6, 7} -- {1, 2, 3, 6, 7}
print(oops[4]) --> 6
```

Другой случай, когда из функции берётся только одно возвращаемое значение, - использование функции в выражении.

```lua
print(foo() * 2) --> 6

-- если нужно принудительно отбросить все значения, кроме первого, можно взять вызов функции в круглые скобки
print((foo())) --> 3
```

#### Аргументы

Как это было видно на примере функции print(), функция может принимать в качестве входных данных одно или несколько значений, называемых аргументами функции. Как и в других языках, имена переменных для требуемых аргументов перечисляются через запятую в круглых скобках при определении функции. При вызове функции же в круглых скобках указываются соответствующие значения, "поступающие на вход".

```lua
local function sign(x)
    if x > 0 then
        return 1
    elseif x < 0 then
        return -1
    else
        return 0
    end
end

print(sign(-16)) --> -1

local function lerp(a, b, amount)
    return a + (b - a) * amount
end

print(lerp(3, 7, 0.375)) --> 4.5
```

Таким образом, по сути, происходит присваивание переданных значений соответствующим локальным переменным. И здесь при несовпадении количества требуемых и переданных аргументов работает то же знакомое правило:

```lua
local function bar(a, b, c)
    print(a, b, c)
end

bar(1, 2) --> 1 2   nil
bar("w", "x", "y", "z") --> "w" "x" "y"
```

Ну, и тут сама напрашивается возможность напрямую использовать возвращаемые из функции значения в качестве аргументов при вызове другой функции. И эта возможность есть:

```lua
bar(foo()) --> 3    4   5
```

Но здесь действует то же ограничение, что и при использовании функций в табличных литералах:

```lua
bar(foo(), 6, 7) --> 3  6   7
```

TODO: значения аргументов по умолчанию

Также существует возможность создать функцию, которая принимает неопределённое количество аргументов. Например, таковой является используемый нами print - он выводит в консоль все значения, которые ему передают. Такие функции называются функциями с переменным числом аргументов и создаются следующим образом:

```lua
local function log(level, ...)
    local date = os.date() -- текущие дата и время
    print(level, date, ...) -- направляем в функцию print попавшие в многоточие аргументы
end

log("warning", "file does not exist", "story.txt") -- "warning" идёт в level, остальные два аргумента - в многоточие
```

По сути, многоточие заменяет собой переданные в функцию значения, перечисленные через запятую, и может использоваться там, где требуется выражение или несколько выражений (с теми же самыми правилами, описанными выше для функций, возвращающих несколько значений). В списке аргументов при определении функции многоточие обязательно должно быть последним (либо единственным).

```lua
local function wtf(...)
    local args = {...}
    local first, second = ...
    local x = ... * 5

    print(..., "a")
    print(first, second, x)
    print((...))
end
```

TODO: unpack

TODO: таблица в качестве аргумента вместо именованных

Кстати, если в функцию нужно передать только один строковый или табличный аргумент в виде литерала (т.е. не переменной, а константой), при вызове функции круглые скобки можно не писать:

```lua
local function poke(name)
    print("Hey, " .. name .. "!")
end

poke "pevzi" --> "Hey, pevzi!"

local function printVector(v)
    print("x: " .. v.x, "y: " .. v.y)
end

printVector {x = 2, y = 3} --> "x: 2"   "y: 3"
```

Так как функции являются значениями, их тоже можно передавать в качестве аргументов в другие функции.

```lua
local function imap(t, f, ...)
    local result = {}

    for i, v in ipairs(t) do
        result[i] = f(v, ...)
    end

    return result
end

local squares = imap({5, 6, 7, 8, 9, 10}, function (v) return v ^ 2 end)

for i, v in ipairs(squares) do
    print(i, v)
end
```

#### Замыкания

TODO: замыкания, upvalues

#### Рекурсия

Функции могут вызывать сами себя (что известно как рекурсия):

```lua
local function factorial(n)
    if n < 0 then
        error("n must be non-negative")
    end

    if n == 0 then
        return 1
    end

    return factorial(n - 1) * n
end
```

При этом следующая запись не заработает так, как ожидается:

```lua
local countdown = function (n) -- обратите внимание на эту строку
    if n <= 0 then
        return
    end

    print(n)

    return countdown(n - 1) -- ошибка: попытка вызвать значение nil
end

countdown()
```

Дело в том, что объявление локальной переменной countdown и присваивание происходят уже после создания функции. Поэтому на момент создания функции локальная переменная countdown ещё не объявлена, и обращение к countdown внутри функции запоминается, как обращение к глобальной переменной countdown. В итоге функция пытается вызвать то, что лежит в глобальной переменной countdown. В нашем случае там ничего не лежало, но могло. Чтобы исправить это недоразумение, можно воспользоваться инструкцией local function:

```lua
local function countdown(n) -- другое дело
    if n <= 0 then
        return
    end

    print(n)

    return countdown(n - 1)
end
```

Эта инструкция, по сути, аналогична следующей записи:

```lua
local countdown
countdown = function (n)
    if n <= 0 then
        -- и т.д.
```

Таким образом, на момент создания функции локальная переменная countdown уже будет существовать, и функция обратится уже к ней. Теперь всё работает как ожидалось.

##### Tail call

Есть и ещё одна тонкость при использовании рекурсии. Если точнее, то она может дать о себе знать и при вызовах других функций, но именно при рекурсии с ней столкнуться проще всего. Речь идёт о переполнении стека. При вызове функции языку необходимо сохранить в памяти некоторую информацию о том, в какое место в коде нужно вернуться после завершения выполнения функции. Эта информация сохраняется в стеке. При выходе из функции эта информация оттуда извлекается и удаляется, а выполнение кода продолжается с соответствующей позиции. Если же та вызванная функция в свою очередь вызывает что-то ещё, то в стек добавляется ещё одна запись. Таким образом, если таких вложенных вызовов будет достаточно много, размер данных в стеке может превысить допустимый. Пронаблюдать эффект можно на примере функции для вычисления факториала, указанной выше, если попробовать вычислить значение факториала какого-нибудь большого числа - через некоторое время вычислений вылезет ошибка stack overflow.

Однако, в языке Lua (точнее, в его реализациях) есть решение этой проблемы. Когда вызов функции производится в самом-самом конце другой функции, никакой информации "о возврате" не записывается, ведь возвращаться в предыдущую функцию уже не нужно, больше там делать нечего. В результате при вызове функции происходит просто прыжок в неё без заполнения стека лишней информацией. Такая оптимизация называется tail call (хвостовой вызов).

Так, например, функция countdown удовлетворяет этому условию, поэтому переполнения стека она не вызовет при любом значении n. А вот factorial после вызова factorial(n - 1) требует ещё и умножения результата на n, так что после выполнения функции нужно туда вернуться и выполнить умножение.

Таким образом, в следующих [примерах](http://www.lua.org/pil/6.3.html) хвостового вызова не происходит:

```lua
return g(x) + 1  -- нужно произвести сложение
return x or g(x) -- требуется отбросить все возвращаемые значения, кроме первого
return (g(x))    -- то же самое
```

Ещё один неочевидный пример, в котором оптимизация не производится:

```lua
local function f(x)
    g(x)
end
```

Здесь загвоздка в том, что после вызова g(x) требуется отбросить лишние значения, которые могут быть возвращены функцией. Таким образом, единственная форма вызова, которая позволяет провести tail call оптимизацию, в общем случае выглядит так:

```lua
return f(аргументы)
```

При этом как f, так и любой из аргументов может быть сложным выражением, так как их значения вычисляются перед вызовом функции. Например, следующий вызов будет являться хвостовым:

```lua
return x[i].foo(x[j] + a*b, i + j)
```

Как можно переписать функцию, вычисляющую факториал, чтобы она использовала рекурсию, но не заполняла стек? Например, так:

```lua
local function factorial(n)
    if n < 0 then
        error("n must be non-negative")
    end

    local function fact(n, res)
        if n == 0 then
            return res
        end

        return fact(n - 1, res * n)
    end

    return fact(n, 1)
end
```

А, и ещё: при tail call оптимизации может несколько затрудниться отладка ввиду отсутствия в стеке информации о вызове функций.

#### Определение и вызов методов

Допустим, у нас есть таблица player, хранящая текущие характеристики игрока, и функция healPlayer для того, чтобы восстановить его здоровье на указанное количество пунктов:

```lua
local player = {x = 10, y = 5, health = 80}

local function healPlayer(player, amount)
    player.health = math.min(player.health + amount, 100)
end

healPlayer(player, 10)
print(player.health) --> 90
```

В такой записи неудобно то, что между объектом player и функцией healPlayer нет никакой явной связи. Если потребуется передать куда-то игрока, то придётся как-то отдельно дать доступ и к функции healPlayer, чтобы там могли знать, как его лечить.

Вместо того, чтобы хранить эту функцию в отдельной локальной переменной, можно сохранить её в самой таблице player в качестве значения под ключом heal. Тогда можно получить что-то похожее на объект с методами, т.е. сущность, объединяющую в себе и данные, и функции для работы с ними:

```lua
local player = {x = 10, y = 5, health = 80}

function player.heal(self, amount)
    self.health = math.min(self.health + amount, 100)
end

player.heal(player, 30)
print(player.health) --> 100
```

Но это всё равно как-то некрасиво - нам приходится вручную передавать в функцию сам же объект в качестве аргумента, чтобы иметь возможность обратиться к его данным. Lua предоставляет специальный синтаксис для более простого определения и вызова таких функций - двоеточие:

```lua
local player = {x = 10, y = 5, health = 80}

function player:heal(amount)
    self.health = math.min(self.health + amount, 100)
end

player:heal(30)
print(player.health) --> 100
```

Теперь это больше похоже на метод. При определении функции двоеточие просто добавляет невидимый первый аргумент self, а при вызове - передаёт в качестве первого аргумента значение, стоящее слева от двоеточия. Таким образом, последние два примера работают совершенно одинаково, просто записаны по-разному.

Главное - не забывать ставить двоеточие вместо точки, когда вызываете методы, потому что тексты ошибок в этом случае обычно не особо поясняют суть того, что пошло не так (в лучшем случае - что-то вроде "произошла попытка проиндексировать число self").

В дальнейшем будут рассмотрены механизмы, которые позволяют реализовать другие привычные концепции объектно-ориентированного программирования.
