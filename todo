http://lua.space/general/blog-opening-and-contribution-guide
http://lua.space/webdev/the-best-lua-web-frameworks

Lua интересен тем, что это действительно маленький и простой язык. Это становится особенно заметно, когда в языке не находишь очередную возможность, которая в других языках стала уже совсем привычной. Однако, несмотря на это, язык не ощущается неполноценным, его можно назвать гибким, выразительным и практичным. К тому же, благодаря минималистичности языка, его реализацию удалось сделать относительно простой, легковесной и быстрой, а также портировать на множество платформ. Более того, существует неофициальная реализация LuaJIT, которая отстаёт от официальной на пару версий, но зато имеет JIT-компилятор для компиляции Lua-кода в машинный код прямо во время исполнения программы. Это позволяет добиться высокой скорости исполнения, которую редко встретишь при использовании динамически типизируемых языков. (привести бенчмарки?)

Lua чаще всего используется для встраивания в другие приложения, в особенности - игры. (для расширения, автоматизации, конфигурационных файлов) (привести примеры) (+ про openresty) (+ про love)

+ оглавление в начале каждой статьи и ссылки на следующую/предыдущую части в конце статьи

Часть 0:
- зачем луа вообще, чем он крут
  - минималистичность, согласованность, простота реализации, высокая производительность
  - если фичи нет, это не значит что лень реализовывать, просто она избыточна
  - в то же время куча гибких базовых механизмов, позволяющих реализовать более конкретные вещи
    - таблицы в качестве словарей, массивов, множеств, объектов, библиотек
    - метатаблицы для реализации классов
    - goto вместо continue, redo, break/continue with labels
  - http://stackoverflow.com/questions/2100902/is-lua-based-primarily-on-well-established-programming-language-ideas
- для кого статья, почему именно такой формат
- в чём писать, как запускать
- про консоль тоже

Часть 1:


Часть 2:


Часть 3:
- одноимённые метки, определённые во вложенном блоке, перекрывают для этого блока внешние метки (т.е. как с переменными)
- добавить побольше разных элементов в оба примера, чтоб явно была видна разница pairs и ipairs

Часть 4:
- "А если такое слово ввести, то все эти сложности с совмещённым присваиванием и объявлением снова перестают иметь смысл." -- нуу, не то чтобы

Часть 5:
- 5.2: Equality between function values has changed. Now, a function definition may not create a new value; it may reuse some previous value if there is no observable difference to the new function.
- в return тоже можно использовать вызов функции с несколькими возвращаемыми значениями
- всё-таки привести пример ООП на основе замыканий, но предупредить, что создание замыканий - довольно дорогая операция

Другое:
- часть 6: модули и пакеты
  - сначала написать про load/loadfile и про чанки
  - чанк - по сути, тело анонимной функции с переменным числом аргументов
    - у чанка тоже есть upvalues, аргументы и возвращаемое значение
    - передать аргументы можно например создав функцию с помощью load/loadfile
  - http://kiki.to/blog/2014/03/30/a-guide-to-authoring-lua-modules/
  - http://www.lua.org/pil/15.html
  - как работает require
    - сохраняет возвращённое из модуля значение в package.loaded под ключом, равным имени модуля
    - если явно ничего не вернулось, то сохраняет там true
    - исполняет модуль только один раз, в дальнейшем просто отдаёт то значение из package.loaded
    - package.loaded - как бы КЭШ
  - НЕ юзать функцию module, ибо устаревшая и в 5.2 её выпилили
  - как указывается путь к модулю
  - где ищутся модули, относительно чего
  - init.lua
  - создаём таблицу с тем, что нужно "экспортировать" и возвращаем её из модуля (или просто возвращаем какое-то значение)
    - не забыть вернуть, а то require вернёт boolean и вылезет странная ошибка
  - модуль может иметь какое-то состояние, к которому можно обращаться из других модулей
    - но так делать нежелательно
  - избегаем глобальных переменных
  - как работают загрузчики
    - в луа 5.3 немного по-другому
  - модуль - отдельный файл, пакет - библиотека (хоть из одного файла, хоть из целого каталога)
- часть 7: другие возможности языка
  - окружения функций
  - generic for
  - корутины
  - метатаблицы
    - fallback
    - __index может быть как функцией так и таблицей
    - перегрузка операторов
    - наследование
    - мемоизация
    - слабые ключи/значения
    - мт на строках
    - мт на _G
      - http://metalua.luaforge.net/src/lib/strict.lua.html / http://lua-users.org/wiki/DetectingUndefinedVariables
    - упомянуть __add и числа (?)
    - может упомянуть что цикл pairs/ipairs не ходит по элементам, "наследованным" через __index
- часть 8: стандартная библиотека
  - стандартные функции
    - можно вызвать next на таблицу, чтобы проверить, есть ли в ней хоть один элемент (включая массивную и хеш части)
  - рассказать про некоторые важные библиотеки + упомянуть что ещё есть
  - может быть найти полностью переведённый референс и дать ссылку
  - лучше юзать table.concat, чем кучу ..
    - и вообще желательно много мусора не создавать (таблиц там)
- часть 9: всякая мелочь/советы ("куда теперь") (?)
  - точки с запятой не нужны, кроме случая, когда строка начинается с выражения в скобках
  - FFI (?)
  - IDE, дебаггер, дополнение, линтеры (?)
  - ссылки на другую полезную инфу
    - http://lua-users.org/wiki/LuaDirectory
    - http://notebook.kulchenko.com/programming/lua-good-different-bad-and-ugly-parts
    - http://www.lua.org/doc/jucs05.pdf
    - http://www.lua.org/gems/sample.pdf
    - http://www.luafaq.org/
    - http://www.luafaq.org/gotchas.html
  - профилирование (?)
    - или оставить его на статью про библиотеки LOVE

Примеры:
- фибоначчи (мемоизация)
- вектор (для __add и методов)

?:
? (стандартные либы юзают raw, а не интерфейс который мы запилили)
  - блин, я уже забыл про что конкретно я это написал
? (обращение к элементам метатаблицы тоже raw, т.е. не учитывается метатаблица у этой метатаблицы)
? (не вызывается tostring для таблиц при конкатенации)
